// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.6.11;
pragma experimental ABIEncoderV2;

// We use the OpenZeppelin ERC-20 token implementation.
import "./ZeppelinERC20.sol";

// Use the UniLottery Randomness Provider to get random seed
// using Provable oracle service (in-contract).
import "./RandomProvider.sol";

// Use CoreSettings.
import "./CoreSettings.sol";


// Interface of the Main Pool Contract, with the functions that we'll
// be calling from our contract.
interface IUniLotteryPool
{
    function syncCurrentPoolBalance()   external ;
    function lotteryFinish( uint totalReturn, uint profitAmount ) external;
}

// Uniswap V2 Router Interface. 
// Used on the Main-Net, and Public Test-Nets.
interface IUniswapRouter
{
    // Get Factory and WETH addresses.
    function factory()  external pure returns (address);
    function WETH()     external pure returns (address);

    // Create/add to a liquidity pair using ETH.
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline )                 
                                        external 
                                        payable 
        returns (
            uint amountToken, 
            uint amountETH, 
            uint liquidity 
        );

    // Remove liquidity pair.
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline ) 
                                        external
        returns (
            uint amountETH
        );

    // Get trade output amount, given an input.
    function getAmountsOut(
        uint amountIn, 
        address[] memory path ) 
                                        external view 
        returns (
            uint[] memory amounts
        );

    // Get trade input amount, given an output.
    function getAmountsIn(
        uint amountOut, 
        address[] memory path )
                                        external view
        returns (
            uint[] memory amounts
        );
}


// Uniswap Factory interface.
// We use it only to obtain the Token Exchange Pair address.
interface IUniswapFactory
{
    function getPair(
        address tokenA, 
        address tokenB )
                                        external view 
    returns ( address pair );
}

// Uniswap Pair interface (it's also an ERC20 token).
// Used to get reserves, and token price.
interface IUniswapPair is IERC20
{
    // Addresses of the first and second pool-kens.
    function token0() external view returns (address);
    function token1() external view returns (address);

    // Get the pair's token pool reserves.
    function getReserves() 
                                        external view 
    returns (
        uint112 reserve0, 
        uint112 reserve1,
        uint32 blockTimestampLast
    );
}



/**
 *  The Universal Lottery Token Contract.
 *
 *  This is the actual lottery logic implementation contract, with whom
 *  all lottery players are interacting with.
 *
 *  Contract instances are highly customizable using the robust 
 *  LotteryConfig configuration structure, in which one can set very
 *  wide range of parameters.
 *  Lottery configuration is initialized at constructor, by passing a
 *  LotteryConfig structure. 
 *  
 *  The configuration can't be changed later - to ensure that players will
 *  all be able to play by the same rules, which are transparent and
 *  immutable during whole lottery lifetime.
 *
 *  ===================================================
 *
 *  Lottery currently supports 2 main types:
 *
 *  1. Uniswap Lottery - uses Uniswap exchange as a mean of distribution.
 *      At lottery initialization, initial token liquidity is provided to
 *      Uniswap, by transfering 100% of the token total supply to
 *      Uniswap liquidity pool.
 *      Initial market cap is equal to lottery initial fund amount.
 *      At lottery finish, all liquidity is taken out of Uniswap, 
 *      then winnings are distributed to winners, and pool profits
 *      and initial funds are transfered back to the pool.
 *
 *  2. Standalone Lottery - lottery contract itself is distributing the
 *      tokens. In this type of lottery, initial funds can be zero,
 *      because selling is disabled by default in contract distributor.
 *      All else happens in "standard way".
 *  
 *  ===================================================
 *
 *  What is the typical lottery workflow?
 *
 *  We consider Uniswap Lottery as the most important example case,
 *  so here we provide a typical flow example of Uniswap Lottery:
 *
 *  1. Pool deploys a new Lottery, passing the LotteryConfig to it's
 *      constructor. The lottery must adhere to the config.
 *
 *  2. Pool transfers initial funds to lottery's fallback fuction.
 *
 *  3. Pool calls this lottery's initialize() function.
 *      This function performs all of the startup tasks - 
 *      provides new liquidity pair to Uniswap, and sets all state
 *      variables accordingly.
 *
 *  4. After this initialize() function returns, pool emits a
 *      LotteryStarted event, and sets all state variables related
 *      to creating a new lottery.
 *
 *  5. Off-chain monitoring applications react to the new LotteryStarted
 *      event, and start advertising campaign for the new lottery.
 *
 *  6. Lottery users play lottery, by buying or selling lottery tokens.
 *      On each token transfer, this lottery contract updates user
 *      scores and other state variables, and checks for finishing
 *      conditions.
 *
 *  7. If a finishing condition evaluates to true, contract transits
 *      to the "finishing stage", on which every transfer will now 
 *      have a probability of ending the lottery.
 *      This probability will get higher with each new transfer and
 *      token holder.
 *      Pseudo-random number will be rolled with the said probability
 *      of getting a certain value to end the lottery.
 *
 *  8. When rolled number satisfies a condition, lottery ending 
 *      process commences.
 *      Lottery is de-activated (all operations on contract will now
 *      fail).
 *      All liquidity is pulled out of Uniswap, and our contract 
 *      initiates a callback request from the Randomness Provider
 *      service contract, which should obtain a random number from
 *      Provable oracle, and call back our lottery contract's
 *      finish_fromRandomnessProvider() function.
 *
 *      Gas fees are sent to Randomness Provider contract from our
 *      lottery contract's funds - which are already obtained, by 
 *      pulling out final liquidity from Uniswap.
 *
 *  9. Randomness Provider obtains a true random seed from Provable,
 *      and calls our contracts callback function, which is
 *      finish_fromRandomnessProvider().
 *      
 *      This function performs final winner selection algorithm, which
 *      is very gas-expensive, and so we pay the gas for it ourselves,
 *      deducting the gas from Uniswap profits, and performing it
 *      using Provable callback mechanism (also described in step 8).
 *
 *      The finish_fromRandomnessProvider() function performs these
 *      tasks, in order:
 *      - We call the Pool function updateCurrentBalance(), which
 *        is used for tracking funds transfered to pool fallback.
 *      - Initial funds + pool profit share is transfered to pool.
 *      - Owner profit share is transfered to owner address.
 *
 *      - Execute winner selection algorithm:
 *        From a passed random seed, we generate random factors for 
 *        each token holder final scores, and then use
 *        QuickSelect & QuickSort to sort and find the lottery winners.
 *      
 *        Finally, we transfer their profit share as winnings to their
 *        addresses.
 *  
 *      At this functions completion, we call the Pool - the 
 *      lotteryFinish() function of the pool contract, which can only
 *      be called by active lotteries.
 *      This function performs all lottery finishing tasks related to
 *      pool state.
 *      Pool accounts the profits, and updates everything related.
 *
 *  This is it. This lottery is now finished, and can never be activated
 *  again. 
 *  However, it will still be possible to read the final state data and
 *  used config properties of this lottery, using view functions.
 *
 *  ======================================================
 *
 *  Which functions of Lottery contract deal with money?
 *
 *  1. [ IN ] The fallback payable function.
 *      Used by the pool for transfering initial funds to this contract.
 *
 *  2. [ OUT ] TODO!
 *
 */
contract Lottery is ERC20, CoreUniLotterySettings
{
    // Lottery types enum.
    enum LotteryType {
        UniswapLottery,
        StandaloneLottery
    }


    /**
     *  The most important stucture of this contract - the LotteryConfig.
     *
     *  Here, we define very wide spectrum of configurations for
     *  token behavior, tokenomics, distribution model, lottery winner
     *  selection algorithms, and much more!
     *
     *  Many of the properties are self-explanatory.
     *  For more complicated ones, detailed explanations are provided
     *  in code parts which deal with those properties.
     */
    struct LotteryConfig 
    {
        // =========== General config =========== //

        // Lottery type (distribution type).
        LotteryType lotteryType;

        // ERC20 token constants.
        string tokenName;
        string tokenSymbol;
        uint256 tokenDecimals;

        // ERC20 Token's initial total supply.
        uint initialTokenSupply;

        // Initial lottery funds (initial market cap).
        // Specified by pool, and is used to check if initial funds 
        // transferred to fallback are correct - equal to this value.
        uint initialFunds;

        // Address of a pool-deployed Randomness Provider, which we
        // use to obtain a random seed for winner selection algorithms.
        address payable randomnessProvider;

        // Owner profit share, and pool profit share percentages.
        // These have a controlled value ranges specified in 
        // CoreUniLotterySettings.
        uint32 ownerProfitShare;
        uint32 poolProfitShare;

        // A fee that Owner can take in lottery tokens as a percentage
        // of every transaction.
        // This is used so Owner would be able to passively have a 
        // chance of getting some lottery wins.
        uint32 ownerLotteryFee;

        // Maximum lifetime of a lottery - maximum amount of time 
        // allowed for lottery to stay active.
        // By default, it's two weeks.
        // If lottery is still active (hasn't returned funds) after this
        // time, lottery will stop on the next token transfer.
        uint32 maxLifetime;

        // Standalone mode only:
        // Set if selling tokens back to this lottery contract is allowed.
        bool standaloneMode_sellingToContractAllowed;

        // =========== Token behavior config =========== //

        // Token burn mode: fixed, custom, or increasing!
        // Notice that burns can be negative - in that case, tokens 
        // are minted instead of being burned!

        // If this bool is set, then burn rate is fixed for every tx.
        bool fixedBurnMode;

        // If set, mints new tokens if burn rate becomes negative.
        bool mintTokensOnNegativeBurn;

        // Fixed-mode burn percentage for every transaction.
        int32 burn_fixedRate;

        // Custom burn rates for sellers, buyers, and default rate
        // (not selling or buying).
        // Here, we set initial rates.
        int32 burn_sellerRate_initial;
        int32 burn_buyerRate_initial;
        int32 burn_defaultRate_initial;

        // Minimum burn rates for the three categories.
        int32 burn_sellerRate_min;
        int32 burn_buyerRate_min;
        int32 burn_defaultRate_min;

        // Maximum burn rates for the three categories.
        int32 burn_sellerRate_max;
        int32 burn_buyerRate_max;
        int32 burn_defaultRate_max;


        // Burn increase mode flag variables:
        // per-transaction, per-holder, per-fund gains.
        bool burnIncrease_perTransaction;
        bool burnIncrease_perHolder;
        bool burnIncrease_perFundGains;

        // Increase percentages for every rate. Can be negative.
        int32 burn_sellerRateIncrease_transaction;
        int32 burn_buyerRateIncrease_transaction;
        int32 burn_defaultRateIncrease_transaction;

        int32 burn_sellerRateIncrease_holder;
        int32 burn_buyerRateIncrease_holder;
        int32 burn_defaultRateIncrease_holder;

        int32 burn_sellerRateIncrease_FundGains;
        int32 burn_buyerRateIncrease_FundGains;
        int32 burn_defaultRateIncrease_FundGains;

        // Specs for specific types of burn increases.
        // Steps on when to perform burn rate increase - 
        // for example, for transactions: if step is 2, then burn
        // rate is increased every 2 transactions.
        uint32 burnIncreaseSpecs_transcation_step;
        uint32 burnIncreaseSpecs_holder_step;

        // (note: not a 32-bit uint, because funds are in ETH, and it's
        //  calculated as a 256-bit uint, so 32-bits would be too low.
        uint burnIncreaseSpecs_FundGains_step;

        // Maximum amount of tokens (in percentage of initial supply)
        // to be allowed to own by a single wallet.
        uint32 maxAmountForWallet_percentageOfSupply;

        // The constant - required amount of time that must pass after
        // the request to Randomness Provider has been made, for
        // external actors to be able to initiate alternative ending.
        uint32 REQUIRED_TIME_WAITING_FOR_RANDOM_SEED;


        // The minimum ETH value gains of lottery funds, that, once
        // reached on an exchange liquidity pool (Uniswap, or our
        // contract), must be guaranteed to not shrink below this value.
        // 
        // This is accomplished in _transfer() function, by denying 
        // all sells that would drop the ETH amount in liquidity pool
        // below this value.
        // 
        // But on initial lottery stage, before this minimum requirement
        // is reached for the first time, all sells are allowed.
        //
        // This value is expressed in percentage increase relative to
        // lottery initial funds.
        //
        // So, if initial funds were 10 ETH, and this is set to 100%,
        // after liquidity pool's ETH value reaches 20 ETH, all further
        // sells which could drop the liquidity amount below 20 ETH,
        // would be denied by require'ing in _transfer() function
        // (transactions would fail).
        //
        uint48 fundGainRequirement_denySells;

        // =========== Lottery Finish criteria =========== //

        // Lottery finish by design is a whole soft stage, that
        // starts when criteria for holders and fund gains are met.
        // During this stage, for every token transfer, a pseudo-random
        // number will be rolled for lottery finish, with increasing 
        // probability.
        //
        // There are 2 ways that this probability increase is 
        // implemented:
        // 1. Increasing on every new holder.
        // 2. Increasing on every transaction after finish stage
        //    was initiated.
        //
        // On every new holder, probability increases more than on
        // new transactions.
        //
        // However, if during this stage some criteria become 
        // no-longer-met, the finish stage is cancelled.
        // This cancel can be implemented by setting finish probability
        // to zero, or leaving it as it was, but pausing the finishing
        // stage.
        // This is controlled by finish_resetProbabilityOnStop flag -
        // if not set, probability stays the same, when the finishing
        // stage is discontinued. 

        // Increase of Lottery Fund ETH value (ETH gains), required
        // to start the finishing stage.
        // Expressed in percentage.
        uint48 finishCriteria_minFundEthGains;

        // Minimum number of token holders required to start the
        // finishing stage.
        uint32 finishCriteria_minNumberOfHolders;

        // Minimum amount of time that lottery must be active.
        uint32 finishCriteria_minTimeActive;

        // Are we resetting finish probability when finishing stage
        // stops, if some criteria are no longer met?
        bool finish_resetProbabilityOnStop;

        // Initial finish probability, when finishing stage was
        // just initiated.
        uint32 finish_initialProbability;

        // Finishing probability increase steps, for every new 
        // transaction and every new holder.
        // If holder number decreases, probability decreases.
        uint32 finish_probabilityIncreaseStep_transaction;
        uint32 finish_probabilityIncreaseStep_holder;


        // =========== Winner selection config =========== //

        // Winner selection algorithm settings.
        //
        // Algorithm is based on score, which is calculated for 
        // every holder on lottery finish, and is comprised of
        // the following parts.
        // Each part is normalized to range ( 0 - scorePoints ), 
        // from smallest to largest value of each holder;
        //
        // After scores are computed, they are multiplied by 
        // holder count factor (holderCount / holderCountDivisor),
        // and finally, multiplied by safely-generated random values,
        // to get end winning scores.
        // The top scorers win prizes.
        //
        // By default setting, max score is 40 points, and it's
        // comprised of the following parts:
        //
        // 1. Ether contributed (when buying from Uniswap or contract). 
        //    Gets added when buying, and subtracted when selling.
        //      Default: 10 points.
        //
        // 2. Amount of lottery tokens holder has on finish.
        //      Default: 5 points.
        //
        // 3. Ether contributed, multiplied by the relative factor
        //      of time - that is, "now" minus "lotteryStartTime".
        //      This way, late buyers can get more points even if
        //      they get little tokens and don't spend much ether.
        //      Default: 5 points.
        //
        // 4. Refferrer bonus. For every player that joined with
        //      your referral ID, you get (that player's score) / 10 
        //      points! This goes up to specified max score.
        //      Also, every player who provides a valid referral ID,
        //      gets 2 points for free!
        //      Default max bonus: 20 points.
        //
        int32 maxPlayerScore_etherContributed;
        int32 maxPlayerScore_tokenHoldingAmount;
        int32 maxPlayerScore_timeFactor;
        int32 maxPlayerScore_refferalBonus;

        // Time factor divisor - interval of time, in seconds, after
        // which time factor is increased by one.
        uint16 timeFactorDivisor;

        // Holder count divisor, used to get the factor by which the
        // scores are multiplied, to take into account the holder amount.
        int16 playerScore_holderCountDivisor;

        // Referral bonus score divisor - how much of the referree's
        // total score the referrer gets.
        // For example, if this is 10, and referree gets 20 points, then
        // referrer's bonus is 20 / 10 = 2 points, for that referree.
        // THIS IS REPLACED BY: accumulated referree scores, normalized to
        // the "maxPlayerScore_refferalBonus" range.
        //
        //int16 playerScore_referreeScoreDivisor;

        // Bonus score a player should get when registering a valid
        // referral code obtained from a referrer.
        int16 playerScore_referralRegisteringBonus;

        // Bonus score that the OWNER_ADDRESS must get.
        int16 playerScore_ownerBonus;

        // =========== Winner profit shares =========== //

        // The winner profit share percentages array. 
        // For example, lottery profits can be distributed this way:
        //
        // Winner profit shares (8 winners):
        // [ 20%, 15%, 10%, 5%, 4%, 3%, 2%, 1% ] = 60% of profits.
        // Owner profits: 10%
        // Pool profits:  30%
        //
        // Pool profit share is not defined explicitly in the config, so
        // when we internally validate specified profit shares, we 
        // assume the pool share to be the left amount until 100% ,
        // but we also make sure that this amount is at least equal to
        // MIN_POOL_PROFITS, defined in CoreSettings.
        //
        uint32[] winnerProfitShares;
    }

    // ============= Events ============= //

    // Emitted when pool transfers initial funds into fallback.
    event InitialFundsTransfered(
        address sender,
        uint amount
    );

    // After initialize() function finishes.
    event LotteryInitialized();

    // Liquidity pair created on Uniswap with initial funds as market cap.
    event UniswapLiquidityCreated(
        address uniPairAddress,
        uint ethAmount,
        uint tokenAmount
    );

    // Emitted on lottery finish, when liquidity is pulled out in the end.
    event UniswapLiquidityRemoved(
        address uniPairAddress,
        uint ethAmount,
        uint tokenAmount
    );

    // Emitted when executing final function, after transferring 
    // profits to their respective owners.
    event LotteryEnd(
        uint initialFunds,
        uint poolProfits,
        uint ownerProfits,
        uint winnerProfits
    );

    // Emitted when on final finish, we call Randomness Provider
    // to callback us with random value.
    event RandomnessProviderCalled();

    // Requirements for finishing stage start have been reached - 
    // finishing stage has started.
    event FinishingStageStarted();

    // We were currently on the finishing stage, but some requirement
    // is no longer met. We must stop the finishing stage.
    event FinishingStageStopped();

    // New Referral ID has been generated.
    event ReferralIDGenerated(
        address referrer,
        uint256 id
    );

    // New referral has been registered with a valid referral ID.
    event ReferralRegistered(
        address referree,
        address referrer,
        uint256 id
    );


    // Standalone Mode events:
    // User sold tokens to our contract, for ETH.
    event SellTokens( 
        address seller,
        uint indexed tokenAmountSold,
        uint indexed tokenAmountWeReceived,
        uint indexed ethSellerReceived
    );

    // User bought tokens from our contract with ETH.
    event BuyTokens( 
        address buyer,
        uint indexed tokenAmountBought,
        uint indexed ethWeReceived
    );


    // ============= State variables ============= //

    // ERC-20 token constants.
    string public name;
    string public symbol;
    uint256 immutable public decimals;

    // The config which is passed to constructor.
    LotteryConfig internal cfg;

    // Pool address. Set on constructor from msg.sender.
    address payable immutable poolAddress;

    // Start date.
    uint public startDate;

    // Computationally more efficient representations for percentage
    // requirements specified in config.
    // We set them in constructor, and don't change them later.

    // For cfg.fundGainRequirement_denySells:
    uint immutable minFundRequirement;

    // For cfg.finishCriteria_minFundEthGains:
    uint immutable finishFundRequirement;

    // The date when Randomness Provider was called, requesting a
    // random seed for the lottery finish.
    uint finish_timeRandomSeedRequested;

    // Transaction count.
    uint32 transactionCount;

    // Current burn rates: seller, buyer, and default.
    // Updated (increased or decreased) on transfers.
    int32 public burnRate_seller;
    int32 public burnRate_buyer;
    int32 public burnRate_default;

    // Burn rate increase factors, cached by the updateBurnRates()
    // function on last burn rate update.
    uint32 burnUpdate_transactionCount;
    uint32 burnUpdate_holderCount;
    uint burnUpdate_FundGains;

    // Finish probability factor cache - the holder count on
    // last update of finish probability.
    int32 finProbUpdate_holderCount;

    // Exchange address. If standalone mode, then it's our contract's
    // address. If Uniswap mode then it's the Uniswap liquidity pair's
    // address, where trades execute.
    address public exchangeAddress;

    // State bools: is lottery currently active?
    bool public isActive = false;

    // Are we currently on finishing stage?
    // This is when all finishing criteria are met, and for every
    // transfer, we're rolling a pseudo-random number to determine
    // if we should end the lottery (move to Ending stage).
    bool public onFinishingStage = false;

    // Are we currently on Final Ending stage (after finishing stage,
    // when lottery is no longer active, and we're waiting for
    // Randomness Provider to call our ending operations callback).
    //
    // Basically this indicates that we're waiting for randomness
    // provider to call our end callback, after we've requested
    // a random seed.
    bool onEndingStage = false;

    // Lottery is absolutely completed - this is set after the
    // Ending Stage ends - that is, after all profits and 
    // winner prizes are distributed.
    // After that, this lottery is no longer usable.
    bool lotteryCompleted = false;

    // If we are, or were before, on finishing stage, this is the
    // probability of lottery getting finished on this transaction.
    uint public finishProbablity;

    // Per-Transaction Pseudo-Random hash value (transferHashValue).
    // This value is computed on every token transfer, by keccak'ing
    // the last (current) transferHashValue, msg.sender, now, and 
    // transaction count.
    //
    // This is used on Finishing Stage, as a pseudo-random number,
    // which is used to check if we should end the lottery (move to
    // Ending Stage).
    uint transferHashValue;

    // Re-Entrancy Locks (Mutexes).
    // We protect for reentrancy in _transfer() function, and
    // in standalone mode's buy and sell functions.
    // Also, we protect on the Final Finishing stages.
    bool buyOrSellOngoing = false;
    bool transferOngoing = false;
    bool finalFinishStageMutex = false;

    // On lottery end, get & store the lottery total ETH return
    // (including initial funds), and profit amount.
    uint ending_totalReturn;
    uint ending_profitAmount;

    // If performing Standalone Mode buys or sells, store the current
    // buy/sell's ether value, to be used when updating holder scores
    // on _transfer() function.
    // Negative value indicates sell, and positive value - buy.
    int currentBuySellEtherValue;

    // The Fee-Free transfer flag.
    // If this flag is specified for the next token transfer, then 
    // _transfer() function just transfers the whole amount directly,
    // without performing any fees/burns nor updating any state data. 
    //
    // Holder data, transaction counts, burn rates - all stay
    // unmodified.
    //
    // The Fee-Free transfers are only used by our contract,
    // on Uniswap mode - to send initial liquidity to Uniswap,
    // and to pull out liquidity from Uniswap in the end.
    //
    bool nextTransfer_FeeFree = false;

    // Specify that Special Transfers are still possible - 
    // this is checked alongside isActive on the _transfer() function.
    // This is needed if we're using Uniswap mode, on the initialization
    // and on the ending phases - as lottery is not active on those 
    // phases, we'll still need a way to transfer tokens between 
    // our contract and Uniswap.
    bool specialTransferMode;

    // Indicator for whether the lottery fund gains have passed a 
    // minimum fund gain requirement.
    // After that time point (when this bool is set), the token sells
    // which could drop the fund value below the requirement, would
    // be denied.
    bool fundGainRequirementReached = false;
    
    
    // Uniswap Router V2 contract instance.
    // Address is the same for MainNet, and all public testnets.
    IUniswapRouter constant uniswapRouter = IUniswapRouter(
        address( 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D ) );

    // WETH address. Set by calling Router's getter, on constructor.
    address WETHaddress;

    // Is the WETH first or second token in our Uniswap Pair?
    bool uniswap_ethFirst;

    // The Lottery Storage contract, which stores all holder data,
    // such as scores, referral tree data, etc.
    LotteryStorage immutable public lotStorage;


    // ============= Private/internal functions ============= //

    // ==================== Other Functions =================== //

    // Pool Only modifier.
    modifier poolOnly {
        require( msg.sender == poolAddress,
                 "Function can be called only by the pool!" );
        _;
    }

    // Only randomness provider allowed modifier.
    modifier randomnessProviderOnly {
        require( msg.sender == cfg.randomnessProvider,
                 "Function can be called only by the UniLottery"
                 " Randomness Provider!" );
        _;
    }

    // Only when lottery is active.
    modifier onlyWhenActive {
        require( isActive, "Function can be called only when active!" );
        _;
    }

    // Only on specific lottery type.
    modifier onlyType( LotteryType lotype ) {
        require( cfg.lotteryType == lotype,
                 "Allowed to call only on other lottery types!" );
        _;
    }

    /**
     *  Uniswap-Only function.
     *  Get our share (ETH amount) of the Uniswap Pair ETH reserve,
     *  of our Lottery tokens ULT-WETH liquidity pair.
     */
    function uniswap_getOurEthAmount()
                                                internal view
    returns( uint ethAmount )
    {
        IUniswapPair pair = IUniswapPair( exchangeAddress );
        
        ( uint112 res0, uint112 res1, ) = pair.getReserves();
        uint resEth = uint( uniswap_ethFirst ? res0 : res1 );

        // Compute our amount of the ETH reserve, based on our
        // percentage of our liquidity token balance to total supply.
        uint liqTokenPercentage = 
            ( pair.balanceOf( address(this) ) * (100 * PERCENT) ) /
            ( pair.totalSupply() );

        // Compute and return the ETH reserve.
        return ( resEth * liqTokenPercentage ) / (100 * PERCENT);
    }
    
    /**
     *  Get uniswap effective ETH price of lottery token amount,
     *  for buys/sells of specific amount of tokens.
     *
     *  @param isBuy - if true, it's a buy. If false, it's a sell.
     *  @param tokenAmount - how many tokens the trader is transfering
     *      to Uniswap pair.
     *  @return - amount of ETH, which the trader is paying/getting
     *      for this operation.
     */
    //function uniswap_getEthPriceForTrade( ... ) ... { ... }


    /**
     *  Check if token transfer to specific wallet won't exceed 
     *  maximum token amount allowed to own by a single wallet.
     *
     *  @return true, if holder's balance with "amount" added,
     *      would exceed the max allowed single holder's balance
     *      (by default, that is 5% of total supply).
     */
    function transferExceedsMaxBalance( 
            address holder, uint amount )
                                                internal view
    returns( bool )
    {
        uint maxAllowedBalance = 
            ( totalSupply() * cfg.maxAmountForWallet_percentageOfSupply ) /
            ( 100 * PERCENT );

        return ( ( balanceOf( holder ) + amount ) > maxAllowedBalance );
    }


    /**
     *  Estimate burn amount for a specific transfer, on current
     *  state of the contract.
     *
     *  Here, we compute burn-or-mint amount for transfer, because
     *  burn rates can be negative - thus minting tokens.
     *
     *  The burn can be affected by 3 different factors, specified
     *  in lottery config - transaction count, holder count, and
     *  current token exchange price.
     *
     *  @param sender   - token sender address.
     *  @param receiver - token receiver address.
     *  @param amount   - token amount being transfered.
     *
     *  @return tokenBurnAmount - an int (not an uint!), because burns can
     *      be negative, thus minting tokens.
     *      If positive value is returned, then tokens are burned.
     *      If negative, then corresponding amount is minted.
     */
    function estimateBurnAmount(
            address sender,
            address receiver,
            uint256 amount )
                                            internal view
    returns( int256 tokenBurnAmount )
    {
        // Check if transaction is a sell, a buy, or default
        // (transfer between holders, not involving an exchange).

        // Sender is an exchange - buy detected.
        if( sender == exchangeAddress && receiver != exchangeAddress ) {
            return ( int(amount) * burnRate_buyer ) / int(100 * PERCENT);
        }

        // Receiver is an exchange - sell detected.
        if( sender != exchangeAddress && receiver == exchangeAddress ) {
            return ( int(amount) * burnRate_seller ) / int(100 * PERCENT);
        }

        // Neither receiver nor sender are an exchanges (or both are
        // an exchange) - use default rate.
        return ( int(amount) * burnRate_default ) / int(100 * PERCENT);
    }

    /**
     *  Estimate total transfer fees for a specific transfer,
     *  from sender's perspective.
     *  Does everything the same as the estimateBurnAmount() (above),
     *  but calculates total fees - so adds an owner fee too.
     *
     *  Notice that fees can be negative - if so, tokens are added
     *  to the sender's balance, instead of being deducted!
     */
    /*function estimateTransferFeesForSender(
            address sender,
            address receiver,
            uint256 amount )
                                            internal view
    returns( int256 totalFeeAmount )
    {
        return  estimateBurnAmount( sender, receiver, amount ) + 
                int( ( amount * cfg.ownerLotteryFee ) / (100 * PERCENT) );
    }*/


    /**
     *  Update holder data.
     *  This function is called by _transfer() function, just before
     *  transfering final amount of tokens directly from sender to
     *  receiver.
     *  At this point, all burns/mints have been done, and we're sure
     *  that this transfer is valid and must be successful.
     *
     *  In all modes, this function is used to update the holder array.
     *
     *  However, on external exchange modes (e.g. on Uniswap mode),
     *  it is also used to track buy/sell ether value, to update holder
     *  scores, when token buys/sells cannot be tracked directly.
     *
     *  If, however, we use Standalone mode, we are the exchange,
     *  so on _transfer() we already know the ether value, which is
     *  set to currentBuySellEtherValue variable.
     *
     *  @param amountSent - the token amount that is deducted from
     *      sender's balance. This includes burn, and owner fee.
     *
     *  @param amountReceived - the token amount that receiver 
     *      actually receives, after burns and fees.
     */
    function updateHolderData_preTransfer(
            address sender,
            address receiver,
            uint256 amountSent,
            uint256 amountReceived )
                                                internal
    {
        // Update holder array, if new token holder joined, or if
        // a holder transfered his whole balance.

        // Sender transferred his whole balance - no longer a holder.
        if( balanceOf( sender ) == amountSent ) 
        {
            lotStorage.removeHolder( sender );
        }

        // Receiver didn't have any tokens before - add it to holders.
        if( balanceOf( receiver ) == 0 && amountReceived > 0 )
        {
            lotStorage.addHolder( receiver );
        }

        // Update holder score factors: if buy/sell occured, update
        // etherContributed and timeFactors scores,
        // and also propagate the scores through the referral chain
        // to the parent referrers.

        // If lottery type is standalone, we don't have to obtain the
        // ether value of the current buy/sell from external sources -
        // the data is managed by our standalone buy/sell functions,
        // which sets the currentBuySellEtherValue variable.
        //
        // But if we're on external exchange mode, we have to find
        // out this value by calling the external exchange contract.

        // If sender or receiver is an exchange, exchange's scores
        // are not updated nor propagated.

        // Temporary variable to store current transfer's buy/sell
        // value in Ethers.
        int buySellValue;

        // Sender is an exchange - buy detected.
        if( sender == exchangeAddress && receiver != exchangeAddress ) 
        {
            // If using external exchange (Uniswap) mode, get ether amount
            // that the buyer is buying tokens for using Uniswap Interface.
            if( cfg.lotteryType == LotteryType.UniswapLottery )
            {
                // Use the Router's functionality.
                // Set the exchange path to WETH -> ULT
                // (ULT is Lottery Token, and it's address is our address).
                address[] memory path = new address[]( 2 );
                path[ 0 ] = WETHaddress;
                path[ 1 ] = address(this);

                uint[] memory ethAmountIn = uniswapRouter.getAmountsIn(
                    amountSent,     // uint amountOut, 
                    path            // address[] path
                );

                buySellValue = int( ethAmountIn[ 0 ] );
            }
            // If standalone mode, currentBuySellEtherValue is already set!
            else {
                buySellValue = currentBuySellEtherValue;
            }

            // Compute time factor value for the current ether value.
            // buySellValue is POSITIVE.
            int timeFactorValue = buySellValue * 
                int( (now - startDate) / cfg.timeFactorDivisor );

            // Update and propagate the buyer (receiver) scores.
            lotStorage.updateAndPropagateScoreChanges(
                    receiver,
                    buySellValue,
                    timeFactorValue,
                    int( amountReceived ) );
        }

        // Receiver is an exchange - sell detected.
        else if( sender != exchangeAddress && receiver == exchangeAddress )
        {
            if( cfg.lotteryType == LotteryType.UniswapLottery ) 
            {
                // Use the Router's functionality.
                // Set the exchange path to ULT -> WETH
                // (ULT is Lottery Token, and it's address is our address).
                address[] memory path = new address[]( 2 );
                path[ 0 ] = address(this);
                path[ 1 ] = WETHaddress;

                uint[] memory ethAmountOut = uniswapRouter.getAmountsOut(
                    amountReceived,     // uint amountIn
                    path                // address[] path
                );

                // It's a sell (ULT -> WETH), so set value to NEGATIVE.
                buySellValue = int( -1 ) * int( ethAmountOut[ 0 ] );
            }
            else {
                buySellValue = currentBuySellEtherValue;
            }

            // Compute time factor value for the current ether value.
            // buySellValue is NEGATIVE.
            int timeFactorValue = buySellValue * 
                int( (now - startDate) / cfg.timeFactorDivisor );

            // Update and propagate the seller (sender) scores.
            lotStorage.updateAndPropagateScoreChanges(
                    sender,
                    buySellValue,
                    timeFactorValue,
                    -1 * int( amountSent ) );
        }

        // Neither Sender nor Receiver are exchanges - default transfer.
        // Tokens just got transfered between wallets, without 
        // exchanging for ETH - so etherContributed_change = 0. 
        // On this case, update both sender's & receiver's scores.
        else {
            buySellValue = 0;

            lotStorage.updateAndPropagateScoreChanges( sender, 0, 0, 
                                            -1 * int( amountSent ) );

            lotStorage.updateAndPropagateScoreChanges( receiver, 0, 0, 
                                            int( amountReceived ) );
        }

        // Check if lottery liquidity pool funds have already
        // reached a minimum required ETH value.
        uint ethFunds = getCurrentEthFunds();

        if( ethFunds >= minFundRequirement )
        {
            fundGainRequirementReached = true;
        }

        // Check whether this token transfer is allowed if it's a sell
        // (if buySellValue is negative):
        //
        // If we've already reached the minimum fund gain requirement,
        // and this sell would shrink lottery liquidity pool's ETH funds
        // below this requirement, then deny this sell, causing this 
        // transaction to fail.

        if( fundGainRequirementReached &&
            buySellValue < 0 &&
            ethFunds - uint( -1 * buySellValue ) <
                minFundRequirement )
        {
            require( false, "This sell would drop the lottery ETH funds"
                            "below the minimum requirement threshold!" );
        }
    }


    /**
     *  Update burn rates, according to new contract state after
     *  transfer occured.
     *  This function is called from _transfer(), after performing
     *  a transfer, and updating all non-finish-related state variables.
     *
     *  Here, we update burn rates according to the burn rate increase
     *  policy, specified in lottery config.
     *  Burn rates can be increased/decreased based on 3 factors - 
     *  transaction count, holder count, and token price.
     *
     *  New burn rates are set, by adding up the specified increase
     *  steps to current burn rates.
     */
    function updateBurnRates()
                                            internal
    {
        // If using fixed rate, nothing needs to be updated.
        if( cfg.fixedBurnMode )
            return;

        // Perform per-transaction burn rate increase.
        // Transaction count cannot decrease, so we don't check abs.value.
        if( cfg.burnIncrease_perTransaction && 
            transactionCount >= 
                ( burnUpdate_transactionCount + 
                  cfg.burnIncreaseSpecs_transcation_step ) )
        {
            burnRate_seller += cfg.burn_sellerRateIncrease_transaction;
            burnRate_buyer  += cfg.burn_buyerRateIncrease_transaction;
            burnRate_default += cfg.burn_defaultRateIncrease_transaction;

            burnUpdate_transactionCount = transactionCount;
        }

        // Perform per-holder burn rate increase.
        // (Block not indented, because of line length limits).
        if( cfg.burnIncrease_perHolder )
        {
        // Compute & check abs.value & sign, and perform operations.
        // Notice that we use sign, so if holder count decreased, then
        // burn rate increase value is subtracted from current burn
        // rate, not added.
        int32 diff = int32( lotStorage.getHolderCount() ) - 
                     int32( burnUpdate_holderCount );
        uint32 abs = uint32( diff < 0 ? (-1 * diff) : diff );
        int32 sign = ( diff < 0 ? int32(-1) : int32(1) );

        // If absolute difference between the old holder count and
        // current holder count is larger than the update step,
        // then perform an update. 
        // For example, if step is 2, old holder count was 7, and now
        // it's 9, then difference is 9-7 = 2, and it's equal or more
        // than step. Perform update.
        // If difference is negative, perform update too, but subtract
        // the increase values from current rates instead of adding
        // (we use "sign" variable for that).
        //
        if( abs >= cfg.burnIncreaseSpecs_holder_step )
        {
            burnRate_seller += sign * cfg.burn_sellerRateIncrease_holder;
            burnRate_buyer  += sign * cfg.burn_buyerRateIncrease_holder;
            burnRate_default += sign * cfg.burn_defaultRateIncrease_holder;

            burnUpdate_holderCount = uint32( lotStorage.getHolderCount() );
        } 
        }

        // Perform per-fund gain burn rate increase.
        if( cfg.burnIncrease_perFundGains )
        {
        uint currentFunds = getCurrentEthFunds();

        int diff = int( currentFunds ) - int( burnUpdate_FundGains );
        uint abs = uint( diff < 0 ? (-1 * diff) : diff );
        int32 sign = ( diff < 0 ? int32(-1) : int32(1) );

        if( abs >= cfg.burnIncreaseSpecs_FundGains_step )
        {
            burnRate_seller += sign * cfg.burn_sellerRateIncrease_FundGains;
            burnRate_buyer  += sign * cfg.burn_buyerRateIncrease_FundGains;
            burnRate_default += sign * cfg.burn_defaultRateIncrease_FundGains;

            burnUpdate_FundGains = currentFunds;
        } 
        }

        // Check & fix, if burn rates exceeded their minimum or
        // maximum limits.

        // Seller burn rate.
        if( burnRate_seller > cfg.burn_sellerRate_max ) {
            burnRate_seller = cfg.burn_sellerRate_max;
        }
        else if( burnRate_seller < cfg.burn_sellerRate_min ) {
            burnRate_seller = cfg.burn_sellerRate_min;
        }

        // Buyer burn rate.
        if( burnRate_buyer > cfg.burn_buyerRate_max ) {
            burnRate_buyer = cfg.burn_buyerRate_max;
        }
        else if( burnRate_buyer < cfg.burn_buyerRate_min ) {
            burnRate_buyer = cfg.burn_buyerRate_min;
        }

        // Default burn rate.
        if( burnRate_default > cfg.burn_defaultRate_max ) {
            burnRate_default = cfg.burn_defaultRate_max;
        }
        else if( burnRate_default < cfg.burn_defaultRate_min ) {
            burnRate_default = cfg.burn_defaultRate_min;
        }
    }


    /**
     *  Check for finishing stage start conditions.
     *  - If some conditions are met, start finishing stage!
     *    Do it by setting "onFinishingStage" bool.
     *  - If we're currently on finishing stage, and some condition
     *    is no longer met, then stop the finishing stage.
     */
    function checkFinishingStageConditions()
                                                    internal
    {
        // Firstly, check if lottery hasn't exceeded it's maximum lifetime.
        // If so, don't check anymore, just set finishing stage, and
        // end the lottery on further call of checkForEnding().
        if( (now - startDate) > cfg.maxLifetime ) 
        {
            onFinishingStage = true;
            return;
        }

        // Compute & check the finishing criteria.

        // Notice that we adjust the config-specified fund gain
        // percentage increase to uint-mode, by adding 100 percents,
        // because we don't deal with negative percentages, and here
        // we represent loss as a percentage below 100%, and gains
        // as percentage above 100%.
        // So, if in regular gains notation, it's said 10% gain,
        // in uint mode, it's said 110% relative increase.
        //
        // (Also, remember that losses are impossible in our lottery
        //  working scheme).

        if( !onFinishingStage
            &&
            lotStorage.getHolderCount() >= cfg.finishCriteria_minNumberOfHolders
            &&
            getCurrentEthFunds() >= finishFundRequirement
            &&
            (now - startDate) >= cfg.finishCriteria_minTimeActive )
        {
            // All conditions are met - start the finishing stage.
            onFinishingStage = true;

            emit FinishingStageStarted();
        }

        else if( onFinishingStage )
        {
            // However, what if some condition was not met, but we're
            // already on the finishing stage?
            // If so, we must stop the finishing stage.
            // But what to do with the finishing probability?
            // Config specifies if it should be reset or maintain it's
            // value until the next time finishing stage is started.
            
            onFinishingStage = false;

            if( cfg.finish_resetProbabilityOnStop )
                finishProbablity = cfg.finish_initialProbability;

            emit FinishingStageStopped();
        }
    }


    /**
     *  We're currently on finishing stage - so let's check if
     *  we should end the lottery now!
     *
     *  This function is called from _transfer(), only if we're sure
     *  that we're currently on finishing stage (onFinishingStage
     *  variable is set).
     *
     *  Here, we compute the pseudo-random number from hash of
     *  current message's sender, now, and other values,
     *  and modulo it to the current finish probability.
     *  If it's equal to 1, then we end the lottery!
     *
     *  Also, here we update the finish probability according to
     *  probability update criteria - holder count, and tx count.
     */
    function checkForEnding()
                                                    internal
    {
        // At first, check if lottery max lifetime is exceeded.
        // If so, start ending procedures right now.
        if( (now - startDate) > cfg.maxLifetime )
        {
            startEndingStage();
            return;
        }

        // Now, we know that lottery lifetime is still OK, and we're
        // currently on Finishing Stage (because this function is
        // called only when onFinishingStage is set).
        //
        // Now, check if we should End the lottery, by computing
        // a modulo on a pseudo-random number, which is a transfer
        // hash, computed for every transfer on _transfer() function.
        //

        // OLD APPROACH: Compute a pseudo random number here.
        // This has flaws, because it's not a chained-hash approach.
        
        //uint256 pseudoRandomNumber = keccak256( abi.encodePacked(
        //    msg.sender, now, holderCount, transactionCount,
        //    finishProbablity ) );

        // Get the modulo amount according to current finish 
        // probability.
        // We use precision of 0.01% - notice the "100 *" before
        // 100 PERCENT.
        // Later, when modulo'ing, we'll check if value is below 100.
        //
        uint modAmount = (100 * 100 * PERCENT) / finishProbablity;

        if( ( transferHashValue % modAmount ) <= 100 )
        {
            // Finish probability is met! Commence lottery end - 
            // start Ending Stage.
            startEndingStage();
            return;
        }

        // Finish probability wasn't met.
        // Update the finish probability, by increasing it!
        // Check if last-update stored criteria value difference
        // with current values is above the step threshold -
        // perform the same procedure as with burn rate updates.

        // Transaction count criteria.
        // As we know that this function is called on every new 
        // transfer (transaction), we don't check if transactionCount
        // increased or not - we just perform probability update.

        finishProbablity += cfg.finish_probabilityIncreaseStep_transaction;

        // Now, perform holder count criteria update, with abs&stuff.
        // As we don't use custom step, we just check if last value
        // and current value differ or not.
        // Also, as we know that single transaction can affect holder
        // count only by 1, we don't check for multiple holder changes.

        int32 diff = int32( lotStorage.getHolderCount() ) - 
                     int32( finProbUpdate_holderCount );

        if( diff != 0 ) {
            finProbUpdate_holderCount = int32( lotStorage.getHolderCount() );

            if( diff > 0 )  // Holder count increased by one.
                finishProbablity += cfg.finish_probabilityIncreaseStep_holder;

            // Holder count decreased by one - also check for overflow.
            else if( finishProbablity > 
                     cfg.finish_probabilityIncreaseStep_holder )
                finishProbablity -= cfg.finish_probabilityIncreaseStep_holder;
        }
    }


    /**
     *  Starts the Ending Stage (Final Ending Stage).
     *
     *  Here, we De-Activate the lottery and set other state variables,
     *  and call the Randomness Provider, asking for a true random seed
     *  to be passed to us into our callback, named 
     *  "finish_randomnessProviderCallback()".
     *
     *  When that callback will be called, the Ending Operations will
     *  commence, starting on ending_Stage_1 function.
     *
     *  Notice that Randomness Provider must already be funded, to
     *  have enough Ether for Provable fee and the gas costs of our
     *  callback function, which are quite high, because of winner
     *  selection algorithm, which is computationally expensive.
     *
     *  The Randomness Provider is always funded by the Pool,
     *  right before the Pool deploys and starts a new lottery, so
     *  as every lottery calls the Randomness Provider only once,
     *  the one-call-fund method for every lottery is sufficient.
     *
     *  Also notice, that Randomness Provider might fail to call
     *  our callback due to some unknown reasons!
     *  Then, the lottery profits could stay locked in this 
     *  lottery contract forever ?!!
     *
     *  No! We've thought about that - we've implemented the
     *  Alternative Ending mechanism, where, if specific time passes 
     *  after we've made a request to Randomness Provider, and
     *  callback hasn't been called yet, we allow external actor to
     *  execute the Alternative ending, which basically does the
     *  same things as the default ending, just that the Random Seed
     *  will be computed locally in our contract, using the
     *  Pseudo-Random mechanism, which could compute a reasonably
     *  fair and safe value using data from holder array, and other
     *  values, described in more detail on corresponding function's
     *  description.
     */
    function startEndingStage()
                                                internal
    {
        // De-Activate the lottery, to deny all further transfers.
        isActive = false;

        // Specify that we've started an Ending Stage.
        onEndingStage = true;

        // Specify that Special Transfers are still possible - 
        // this is checked alongside isActive on the _transfer() function.
        // This is needed if we're using Uniswap mode - as lottery is
        // no longer active, we'll need a way to transfer tokens from
        // Uniswap back to us.
        specialTransferMode = true;

        // We're sure that the Randomness Provider has enough funds.
        // Execute the random request, and get ready for STAGE TWO !
        (UniLotteryRandomnessProvider)( cfg.randomnessProvider )
            .requestRandomSeedForLotteryFinish();

        // Store the time when random seed has been requested, to
        // be able to alternatively handle the lottery finish, if
        // randomness provider doesn't call our callback for some
        // reason.
        finish_timeRandomSeedRequested = now;

        // Emit appropriate events.
        emit RandomnessProviderCalled();
    }


    /** PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     *
     *  Execute Ending Stage - Part One.
     *
     *  This function is called from the Randomness Provider Callback
     *  (finish_randomnessProviderCallback) - so the Randomness
     *  Provider already has given us the Random Seed.
     *  Or, maybe we're getting called from Alternative Ending
     *  function, if randomness Provider failed to do it's job.
     *
     *  This function's job is to Gather the Profits & Initial Funds,
     *  and Transfer them to Profiters - that is, to The Pool, and
     *  to The Owner.
     *
     *  On this function, we (in this order):
     *
     *  1. Remove all liquidity from Uniswap (if using Uniswap Mode),
     *      pulling it to our contract's wallet.
     *
     *  2. Transfer the Owner and the Pool ETH profit shares to
     *      Owner and Pool addresses.
     *
     *  * This function transfers Ether out of our contract:
     *      - We transfer the Profits to Pool and Owner addresses.
     */
    function ending_Stage_1 ()
                                                    internal
    {
        // Check & Lock the Re-Entrancy lock mutex.
        require( !finalFinishStageMutex, "No re-entrant calls allowed!" );
        finalFinishStageMutex = true;

        // If using Uniswap mode, pull out all liquidity from Uniswap.
        if( cfg.lotteryType == LotteryType.UniswapLottery )
        {
            // Set Fee-Free transfer mode.
            nextTransfer_FeeFree = true;

            // We've already approved our token allowance to Router, 
            // so now just call removeLiquidityETH on the Router.

            uint amountETH = uniswapRouter
                .removeLiquidityETHSupportingFeeOnTransferTokens(
                    address(this),          // address token,
                    IUniswapPair(exchangeAddress).balanceOf( address(this) ),
                    0,                      // uint amountTokenMin,
                    cfg.initialFunds,       // uint amountETHMin,
                    address(this),          // address to,
                    (now + 1000)            // uint deadline
                );

            // Check that we've got a correct amount of ETH.
            require( address(this).balance >= amountETH &&
                     address(this).balance >= cfg.initialFunds,
                     "Incorrect amount of ETH received from Uniswap!" );
        }

        // Compute the Profit Amount (current balance - initial funds).
        ending_totalReturn = address(this).balance;
        ending_profitAmount = ending_totalReturn - cfg.initialFunds;

        // Sync pool's ETH balance tracker before transfer.
        IUniLotteryPool( poolAddress ).syncCurrentPoolBalance();

        // Compute, and Transfer Owner's profit share and 
        // Pool's profit share to their respective addresses.

        uint poolShare = ( ending_profitAmount * cfg.poolProfitShare ) /
                         ( 100 * PERCENT );

        uint ownerShare = ( ending_profitAmount * cfg.ownerProfitShare ) /
                          ( 100 * PERCENT );

        // To pool, transfer it's profit share plus initial funds.
        poolAddress.transfer( poolShare + cfg.initialFunds );

        // Transfer Owner's profit share.
        OWNER_ADDRESS.transfer( ownerShare );

        // Un-Lock the Re-Entrancy Lock.
        finalFinishStageMutex = false;
    }


    /** PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     *
     *  Executes the Ending Stage - Part Two.
     *
     *  On this stage, the Winner Prize Funds are distributed to 
     *  Lottery Winners, using a Winner Selection Algorithm, which
     *  is executed by calling a function on our Storage contract.
     *  Everything is then performed inside the Storage contract.
     *
     *  Notice that at the point when this function is called,
     *  all funds left in our Lottery contract are the
     *  Winner Prize Funds, which must all be distributed to
     *  lottery winners.
     *
     *  * This function transfers Ether out of our contract:
     *      - Transfers Ether to the Storage contract, when calling
     *        the executeWinnerSelectionAlgorithm() function on
     *        that contract.
     *        All our current funds are transfered there, to be
     *        distributed to Lottery Winners.
     */
    function ending_Stage_2 ( uint256 randomSeed )
                                                            internal
    {
        // Check & Lock the Re-Entrancy lock mutex.
        require( !finalFinishStageMutex, "No re-entrant calls allowed!" );
        finalFinishStageMutex = true;

        // Setup a Winner Score Config for the winner selection algo.
        LotteryStorage.WinnerAlgorithmConfig memory winnerConfig;

        // Individual player max score parts.
        winnerConfig.maxPlayerScore_etherContributed =
            cfg.maxPlayerScore_etherContributed;

        winnerConfig.maxPlayerScore_tokenHoldingAmount =
            cfg.maxPlayerScore_tokenHoldingAmount;

        winnerConfig.maxPlayerScore_timeFactor =
            cfg.maxPlayerScore_timeFactor;

        winnerConfig.maxPlayerScore_refferalBonus =
            cfg.maxPlayerScore_refferalBonus;

        // Holder count divisor, used to get the factor by which the
        // scores are multiplied, to take into account the holder amount.
        winnerConfig.playerScore_holderCountDivisor =
            cfg.playerScore_holderCountDivisor;

        // The Winner Prize Fund shares, as percentages of total
        // lottery profit shares.
        winnerConfig.winnerProfitShares =
            cfg.winnerProfitShares;

        // Launch the winner config (transfer Ether too).
        lotStorage.executeWinnerSelectionAlgorithm
        { value: address(this).balance }
        ( randomSeed, winnerConfig );


        // That's it! We're done!
        // Now, set the lottery as absolutely completed.
        lotteryCompleted = true;
        isActive = false;
        specialTransferMode = false;

        // Notify the Pool about our completion.
        IUniLotteryPool( poolAddress ).lotteryFinish( 
                ending_totalReturn, ending_profitAmount );

        // Un-Lock the Re-Entrancy Lock.
        finalFinishStageMutex = false;
    }



    // =============== Public functions =============== //

    /**
     *  Constructor.
     *  Here, we assign the Pool Address to the sender's one,
     *  and set our LotteryConfig (cfg).
     *  Before setting, we validate the config.
     */
    constructor( LotteryConfig memory config,
                 address payable _poolAddress,
                 address _storageAddress )
                                                    public
    {
        // Set the Pool's Address - notice that it's not the
        // msg.sender, because lotteries aren't created directly
        // by the Pool, but by the Lottery Factory!
        poolAddress = _poolAddress;

        // Set our Storage, and initialize it (bind it to our contract).
        lotStorage = LotteryStorage( _storageAddress );
        lotStorage.initialize();

        // Check if profit shares specified in cfg are valid, and
        // sum up to 100%.
        uint totalWinnerShare = 0;
        for( uint i = 0; i < config.winnerProfitShares.length; i++ ) {
            totalWinnerShare += config.winnerProfitShares[ i ];
        }

        // Must sum up to 100% with the error allowance of 0.001% .
        require( ( 100 * PERCENT ) - 
                 ( totalWinnerShare + config.poolProfitShare +
                   config.ownerProfitShare ) < ( PERCENT / 1000 ) ,
                 "Specified profit shares don't sum up to 100% !" );

        // Check the minimum & maximum requirements for config
        // profit & lifetime parameters.
        require( totalWinnerShare >= MIN_WINNER_PROFIT_SHARE,
                 "Winner profit share is too low!" );

        require( config.poolProfitShare >= MIN_POOL_PROFITS &&
                 config.poolProfitShare <= MAX_POOL_PROFITS,
                 "Pool profit share is invalid!" );

        require( config.ownerProfitShare >= MIN_OWNER_PROFITS &&
                 config.ownerProfitShare <= MAX_OWNER_PROFITS,
                 "Owner profit share is invalid!" );

        require( config.maxLifetime <= MAX_LOTTERY_LIFETIME,
                 "Lottery maximum lifetime is too high!" );
        
        // Now, set our config to the passed config.
        cfg = config;

        // Set the ERC-20 constants.
        name = cfg.tokenName;
        symbol = cfg.tokenSymbol;
        decimals = cfg.tokenDecimals;

        // Compute and set the fund requirement constants which are
        // expressed in percentages in lottery config, but in practice,
        // need to be checked in absolute values.
        minFundRequirement = 
            ( cfg.initialFunds * 
            ( cfg.fundGainRequirement_denySells + (100 * PERCENT) ) ) /
            ( 100 * PERCENT );

        finishFundRequirement = 
            ( cfg.initialFunds * 
            ( cfg.finishCriteria_minFundEthGains + (100 * PERCENT) ) ) /
            ( 100 * PERCENT );

        // If using Uniswap Mode, set the W3TH address.
        if( cfg.lotteryType == LotteryType.UniswapLottery )
        {
            WETHaddress = uniswapRouter.WETH();
        }
    }


    /** PAYABLE [ IN ] <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     *
     *  The fallback payable function.
     *  This function is used by the pool, just after constructing
     *  this lottery, to transfer initial funds to this lottery.
     */
    receive ()  external payable 
    {
        emit InitialFundsTransfered( msg.sender, msg.value );
    }


    /** PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>
     *
     *  Initialization function.
     *  Here, the most important startup operations are made - 
     *  such as minting initial token supply and transfering it to
     *  the Uniswap liquidity pair, in exchange for UNI-v2 tokens.
     *
     *  This function is called by the pool just after transfering
     *  initial funds to this contract.
     *
     *  What's payable? We transfer Ether to Uniswap liquidity pair
     *  when creating/providing it.
     */
    function initialize()   
                            external
                            poolOnly
    {
        // Check if pool transfered correct amount of funds.
        require( address( this ).balance == cfg.initialFunds,
                 "Invalid amount of funds transfered!" );

        // Set start date.
        startDate = now;

        // Set the initial transfer hash value.
        transferHashValue = uint( keccak256( abi.encodePacked(
            transferHashValue, msg.sender, now, transactionCount ) ) );

        // Set initial burn rates.
        burnRate_seller = cfg.burn_sellerRate_initial;
        burnRate_buyer = cfg.burn_buyerRate_initial;
        burnRate_default = cfg.burn_defaultRate_initial;

        // Set initial finish probability, to be used when finishing
        // stage starts.
        finishProbablity = cfg.finish_initialProbability;

        // Set initial caches for the burn rate update function,
        // and finish probability update function.
        // Transaction and holder counts are Zero in the beginning,
        // so they don't need setting.
        // However, market cap needs to be set to initial funds!
        burnUpdate_FundGains = cfg.initialFunds;

        // Add owner to Holders list, because as we use owner fee
        // for transfers, for every transfer, owner will get a 
        // percentage of tokens.
        // Also, Owner gets some bonus points.
        lotStorage.addHolder( OWNER_ADDRESS );
        
        if( cfg.playerScore_ownerBonus )
        {
            lotStorage.setHolderBonusScore(
                OWNER_ADDRESS,
                cfg.playerScore_ownerBonus );
        }

        // ===== Active operations - mint & distribute! ===== //

        // Set Special Transfer & Fee-Free mode to allow transfers
        // in inactive mode, and not perform any state updates & burns.
        specialTransferMode = true;
        nextTransfer_FeeFree = true;

        // Mint full initial supply of tokens to our contract address!
        _mint( address(this), cfg.initialTokenSupply );

        // If lottery type is Standalone, then all trading is done
        // in this contract itself, so no liquidity needs to be 
        // put anywhere. Only set exchange address.
        if( cfg.lotteryType == LotteryType.StandaloneLottery )
        {
            exchangeAddress = address( this );
        }

        // However, if Uniswap type is used, we must now provide
        // liquidity to Uniswap, by creating a new liquidity pair!
        else if( cfg.lotteryType == LotteryType.UniswapLottery )
        {
            // Set the Fee-Free transfer flag - next transfer, which
            // will be the token transfer to Uniswap Liquidity Pair
            // when creating it, will be free-of-fees - nothing will
            // be burned.
            nextTransfer_FeeFree = true;

            // Approve Uniswap Router to allow it to spend our tokens.
            // Set maximum amount available.
            approve( address( uniswapRouter ), uint( -1 ) );

            // Provide liquidity - the Router will automatically
            // create a new Pair.
            
            uniswapRouter.addLiquidityETH 
            { value: address(this).balance }
            (
                address(this),          // address token,
                totalSupply(),          // uint amountTokenDesired,
                totalSupply(),          // uint amountTokenMin,
                address(this).balance,  // uint amountETHMin,
                address(this),          // address to,
                (now + 1000)            // uint deadline
            );

            // Get the Pair address - that will be the exchange address.
            exchangeAddress = IUniswapFactory( uniswapRouter.factory() )
                .getPair( WETHaddress, address(this) );

            // We assume that the token reserves of the pair are good,
            // and that we own the full amount of liquidity tokens.

            // Find out which of the pair tokens is WETH - is it the 
            // first or second one. Use it later, when getting our share.
            if( IUniswapPair( exchangeAddress ).token0() == WETHaddress )
                uniswap_ethFirst = true;
            else
                uniswap_ethFirst = false;
        }

        // Disable special transfer modes.
        specialTransferMode = false;
        nextTransfer_FeeFree = false;

        // Activate lottery.
        isActive = true;

        // Lottery is initialized. We're ready to emit event.
        emit LotteryInitialized();
    }


    // Return this lottery's initial funds, as were specified in the config.
    //
    function getInitialFunds()          external view
    returns( uint )
    {
        return cfg.initialFunds;
    }

    // Return active (still not returned to pool) initial fund value.
    //
    function getActiveInitialFunds()    external view
    returns( uint )
    {
        if( isActive )
            return cfg.initialFunds;

        // If no-longer-active, return 0 - because funds were 
        // already returned back to the pool.
        return 0;
    }


    /**
     *  Get market cap (tokenPrice * totalSupply).
     *  If standalone mode, use our balance, because we're the
     *  main exchange.
     *  If uniswap mode, get price from Uniswap.
     */
    function getMarketCap() 
                                                external view
    returns( uint )
    {
        if( cfg.lotteryType == LotteryType.StandaloneLottery ) 
        {
            // Use our liquidity pool's price - Eth/Token balance.
            return ( totalSupply() * address( this ).balance ) /
                     balanceOf( address( this ) );
        }
        else if( cfg.lotteryType == LotteryType.UniswapLottery )
        {
            // Use data from Uniswap pair contract.
            ( uint112 res0, uint112 res1, uint32 ts ) = 
                IUniswapPair( exchangeAddress ).getReserves();

            return ( uniswap_ethFirst ?
                     ( ( totalSupply() * uint(res0) ) / uint(res1) ) :
                     ( ( totalSupply() * uint(res1) ) / uint(res0) ) );
        }
        return 0;
    }

    /**
     *  Get current Exchange's Token and ETH reserves.
     *  If standalone mode, use our ETH and ULT token balances,
     *  because we're the main exchange.
     *  If uniswap mode, get reserves from Uniswap.
     */
    function getReserves() 
                                                        external view
    returns( uint _ethReserve, uint _tokenReserve )
    {
        if( cfg.lotteryType == LotteryType.StandaloneLottery ) 
        {
            // Use our liquidity pool's reserve balances.
            return ( address(this).balance, balanceOf( address(this) ) );
        }
        else if( cfg.lotteryType == LotteryType.UniswapLottery )
        {
            // Use data from Uniswap pair contract.
            ( uint112 res0, uint112 res1, uint32 ts ) = 
                IUniswapPair( exchangeAddress ).getReserves();

            if( uniswap_ethFirst )
                return ( res0, res1 );
            else
                return ( res1, res0 );
        }
    }


    /**
     *  Get current ETH funds in lottery token exchange liquidity pool.
     *  If we're using Uniswap, fetch data from Uniswap pair contract.
     *  If we're on Standalone Mode, we're the exchange, so just
     *  return our contract's ETH balance.
     */
    function getCurrentEthFunds()
                                        public view
    returns( uint )
    {
        if( cfg.lotteryType == LotteryType.StandaloneLottery ) {
            return address( this ).balance;
        }
        else if( cfg.lotteryType == LotteryType.UniswapLottery ) 
        {
            // Use data from Uniswap pair contract.
            ( uint112 res0, uint112 res1, ) = 
                IUniswapPair( exchangeAddress ).getReserves();

            return uint( uniswap_ethFirst ? res0 : res1 );
        }
        return 0;
    }

    /**
     *  Get price of a whole token (no fractions).
     *  If standalone mode, use our own pool to determine price,
     *  and if Uniswap mode, get data from Uniswap.
     */
    function getWholeTokenPrice()
                                        public view
    returns( uint )
    {
        if( cfg.lotteryType == LotteryType.StandaloneLottery ) 
        {
            return address( this ).balance /
                   ( balanceOf( address(this) ) / (10 ** decimals) );
        }
        else if( cfg.lotteryType == LotteryType.UniswapLottery )
        {
            // Use data from Uniswap pair contract.
            ( uint112 res0, uint112 res1, uint32 ts ) = 
                IUniswapPair( exchangeAddress ).getReserves();

            return ( uniswap_ethFirst ?
                     ( uint(res0) / ( uint(res1) / (10 ** decimals) ) ) :
                     ( uint(res1) / ( uint(res0) / (10 ** decimals) ) ) );
        }
        return 0;
    }

    /**
     *  Simulate a transaction, and estimate the token amount that
     *  receiver should receive after all burns & fees.
     *  Amount received can't be negative, so it's an uint.
     */
    function estimateAmountReceived(
            address sender,
            address receiver,
            uint256 amount )
                                                public view
    returns( uint256 amountReceived )
    {
        // If tokens are minted, they are minted into sender's balance,
        // so the receiver doesn't receive them, thus burn in receiver's
        // perspective is zero.
        int burns = estimateBurnAmount( sender, receiver, amount );
        uint ownerFee = ( amount * cfg.ownerLotteryFee ) / (100 * PERCENT);
        
        return amount - ownerFee - ( burns > 0 ? uint(burns) : 0 );
    }


    // -------------- Standalone Mode Only -------------- //

    /** PAYABLE [ IN ] <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     *
     *  Standalone mode only - buy tokens from this contract.
     *  Uses a liquidity pool based approach to determine price.
     *
     *  Basis it this:
     *  t * e = z ,
     *  where t is our token balance, e is our eth balance, and z is the
     *  constant value which must be maintain'd.
     *
     *  When buyer wants to buy a token, he sends X amount of eth, 
     *  and in return, we deduct Y amount of tokens from our balance, 
     *  and transfer it to buyer.
     *  In practice, buyer will get less than Y tokens, because of
     *  burns and transfer fees.
     *
     *  So, we get a new equation:
     *
     *  (t - y) * (e + x) = z 
     *
     *  We know:
     *  - t (our token balance),
     *  - e (our eth balance, before the buyer sent x eth to us),
     *  - x (the amount of eth buyer sent to us to buy tokens with),
     *  - z (absolute value constant, equal to (t * e)).
     *
     *  We want to find y, which is the amount of tokens that must
     *  be deducted from our token balance and sent to buyer.
     *  
     *  So, the equation for y is:
     *
     *  y = t - ( z / (e + x) )
     *
     *  OR, without using z:
     *
     *  y = t - ( (t * e) / (e + x) )
     *  
     *  That is the amount of tokens user we should transfer to
     *  the buyer. Actual amount buyer gets is lower, because of burn.
     *
     *  However, if y is lower than minTokenAmountWanted, transaction
     *  reverts.
     *  minTokenAmountWanted is used to account for slippage.
     */
    function standalone_buyTokens( 
            uint minTokenAmountWanted )
                                    external
                                    payable 
                                    onlyWhenActive
                                    onlyType( LotteryType.StandaloneLottery )
    returns( uint amountBought )
    {
        // Check & Lock ReEntrancy Lock Mutex.
        require( !buyOrSellOngoing, "Buy or sell already ongoing!" );
        buyOrSellOngoing = true;

        require( msg.value != 0, "Token price can't be zero!" );

        // Compute the new price and a token amount the caller
        // should get with his ETH added to our balance,
        // according to the formula described above.
        // y = tokenBuyAmount.

        uint x = msg.value;                 // Buyer's sent ETH value.
        uint e = address(this).balance - x; // Our ETH balance before buy.
        uint t = balanceOf( address(this) );   // Our token balance.

        uint tokenBuyAmount = t - ( (t * e) / (e + x) );

        require( tokenBuyAmount >= minTokenAmountWanted &&
                 tokenBuyAmount < balanceOf( address(this) ),
                 "Slippage was too high!" );

        // Set the current operation's (buy) ether value, to be
        // used when updating holder scores on _transfer().
        currentBuySellEtherValue = int( msg.value );

        // Transfer tokens to the buyer. Notice that burns happen!
        _transfer( address(this), msg.sender, tokenBuyAmount );

        // Emit approppriate events, and return.
        emit BuyTokens( msg.sender, tokenBuyAmount, msg.value );

        // Unlock ReEntrancy Lock Mutex-Futex.
        buyOrSellOngoing = false;

        return tokenBuyAmount;
    }


    /** PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     *
     *  Sell tokens for ETH.
     *  Performs basically the same operations as buying, just
     *  that the formula is used with X as the unknown variable.
     *
     *  (t + y) * (e - x) = (t * e)
     *
     *  We need x, so:
     *
     *  x = e - ( (t * e) / (t + y) )
     *
     *  Notice, that we'll get lower amount of tokens than the
     *  user transfered, because of burning.
     *
     *  @param tokenAmount  - token amount to sell.
     *  @param minEthWanted - minimum amount of ETH buyer wants to
     *      get. This is used to account for slippage.
     */
    function standalone_sellTokens( 
            uint tokenAmount,
            uint minEthWanted )
                                    external
                                    onlyWhenActive
                                    onlyType( LotteryType.StandaloneLottery )
    returns( uint ethAmountReceived )
    {
        // Check if selling to contract is allowed in config.
        require( cfg.standaloneMode_sellingToContractAllowed,
                 "Selling to our contract is not allowed!" );

        // Check & Lock Mutex.
        require( !buyOrSellOngoing, "Buy or sell already ongoing!" );
        buyOrSellOngoing = true;

        // Check if amount is not exceeding seller's balance.
        require( tokenAmount > 0 && tokenAmount <= balanceOf( msg.sender ),
                 "Invalid token amount specified!" );

        // To find out the amount of tokens we will actually receive,
        // store our token balance before transfer, and execute transfer.
        uint tokenBalanceBefore = balanceOf( address(this) );

        // Transfer tokens to our address.
        _transfer( msg.sender, address(this), tokenAmount );

        // Now, our token balance have been updated - we can find
        // y - the amount of tokens that we actually received.
        uint y = balanceOf( address(this) ) - tokenBalanceBefore;

        // Now, we can use use the formula.
        uint t = tokenBalanceBefore;
        uint e = address(this).balance;     // Our ETH balance.

        // Check if conditions are good.
        require( ( e > ( (t * e) / (t + y) ) ),
                 "Formula pre-conditions are invalid!" );

        uint ethToReceive = e - ( (t * e) / (t + y) );

        // Check for slippage.
        require( ethToReceive >= minEthWanted,
                 "Slippage was too high!" );

        // Check if we're not transfering away our initial funds!
        require(   address(this).balance > ethToReceive &&
                 ( address(this).balance - ethToReceive ) > cfg.initialFunds,
                 "ethToReceive exceeds initial funds!" );

        // Set the current operation's (selling) ether value, to be
        // used when updating holder scores on _transfer().
        // On sell, it must be negative.
        currentBuySellEtherValue = -1 * int( ethToReceive );

        // Finally send ETH from our contract to the seller.
        ( msg.sender ).transfer( ethToReceive );

        // Emit approppriate events, and return.
        emit SellTokens( msg.sender, tokenAmount, y, ethToReceive );

        // Unlock reentrancy lock.
        buyOrSellOngoing = false;

        return ethToReceive;
    }

    // ---------- [END] Standalone Mode Functions [END] ---------- //


    /**
     *  Generate a referral ID for msg.sender, who must be a token holder.
     *  Referral ID is used to refer other wallets into playing our
     *  lottery.
     *  - Referrer gets bonus points for every wallet that bought 
     *    lottery tokens and specified his referral ID.
     *  - Referrees (wallets who got referred by registering a valid
     *    referral ID, corresponding to some referrer), get some
     *    bonus points for specifying (registering) a referral ID.
     *
     *  Referral ID is a uint256 number, which is generated by
     *  keccak256'ing the holder's address, holder's current
     *  token ballance, and current time.
     */
    function generateReferralID()
                                                    external
                                                    onlyWhenActive
    {
        uint256 refID = lotStorage.generateReferralID( msg.sender );

        // Emit approppriate events.
        emit ReferralIDGenerated( msg.sender, refID );
    }


    /**
     *  Register a referral for a msg.sender (must be token holder),
     *  using a valid referral ID got from a referrer.
     *  This function is called by a referree, who obtained a
     *  valid referral ID from some referrer, who previously
     *  generated it using generateReferralID().
     *
     *  You can only register a referral once!
     *  When you do so, you get bonus referral points!
     */
    function registerReferral( uint256 referralID )
                                                    external
                                                    onlyWhenActive
    {
        address referrer = lotStorage.registerReferral( 
                msg.sender,
                cfg.playerScore_referralRegisteringBonus,
                referralID );

        // Emit approppriate events.
        emit ReferralRegistered( msg.sender, referrer, referralID );
    }


    /**
     *  The most important function of this contract - Transfer Function.
     *
     *  Here, all token burning, intermediate score tracking, and 
     *  finish condition checking is performed, according to the 
     *  properties specified in config.
     */
    function _transfer( address sender,
                        address receiver,
                        uint256 amount )
                                            internal
                                            override
    {
        // Check if transfers are allowed in current mode.
        require( isActive || specialTransferMode,
                 "Transfers are not allowed in current state!" );

        // Check & Lock mutex - to prevent re-entrant transfer calls.
        require( !transferOngoing, "Transfer is currently ongoing!" );
        transferOngoing = true;

        // Can't transfer zero tokens, or use address(0) as sender.
        require( amount != 0 && sender != address(0),
                 "Amount is zero, or transfering from zero address." );

        // If Special Transfer Mode is currently used, check if
        // sender & receiver addresses are allowed to transfer tokens
        // in special mode.
        // Currently that's only allowed between the Uniswap Pair
        // contract and our contract, if using Uniswap mode.
        if( !isActive && specialTransferMode &&
            cfg.lotteryType == LotteryType.UniswapLottery )
        {
            require( 
                ( sender == address(this) || sender == exchangeAddress ) &&
                ( receiver == address(this) || receiver == exchangeAddress ),
                "Sender or Receiver address is not allowed in Special mode!"
            );
        }

        // If Fee-Free transfer flag was specified for the next
        // transfer (this transfer), then just transfer the whole 
        // amount directly, without performing any fees/burns nor
        // updating any state data. 
        // Holder data, transaction counts, burn rates - all stay
        // unmodified.
        // The Fee-Free transfers are only used by our contract,
        // on Uniswap mode - to send initial liquidity to Uniswap,
        // and to pull out liquidity from Uniswap in the end.

        if( nextTransfer_FeeFree )
        {
            super._transfer( sender, receiver, amount );

            // Reset the Fee-Free transfer flag.
            nextTransfer_FeeFree = false;

            // UnLock the Re-Entrancy Lock, and Return.
            transferOngoing = false;
            return;
        }

        // Compute, and execute an amount of transaction to be burned.
        int burnAmount = estimateBurnAmount( sender, receiver, amount );
        uint mintAmount = 0;

        // Burn amount can be negative. If so, we can mint tokens.
        // Minted tokens are added to sender's balance.
        // If so, set burn amount to 0 after operation, to avoid errors
        // when computing final tranfer amount.
        if( burnAmount < 0 && cfg.mintTokensOnNegativeBurn ) 
        {
            mintAmount = uint( -1 * burnAmount );
            burnAmount = 0;
        }

        // If owner lottery token fee is specified, transfer a 
        // percentage of transaction to owner's address.
        uint ownerFeeAmount = 0;
        if( cfg.ownerLotteryFee > 0 )
        {
            ownerFeeAmount = ( amount * cfg.ownerLotteryFee ) / 
                             ( 100 * PERCENT );

            // Check if owner wallet is not exceeding max wallet balance.
            // If not, execute transfer to owner's wallet.
            if( transferExceedsMaxBalance( OWNER_ADDRESS, ownerFeeAmount ) )
                ownerFeeAmount = 0;
        }

        // Finally, transfer the leftover tokens from sender to receiver,
        // if receiver's balance won't exceed the max amount allowed.
        uint finalAmount = amount - ownerFeeAmount - uint( burnAmount );

        require( !transferExceedsMaxBalance( receiver, finalAmount ),
                 "Receiver's balance would exceed maximum after transfer!");

        // Now, update holder data array accordingly.
        updateHolderData_preTransfer( 
                sender, 
                receiver, 
                amount,             // Amount Sent (Pre-Fees)
                finalAmount         // Amount Received (Post-Fees).
        );

        // All is ok - perform all token transfers now: 
        // burn, owner fee, and sender->receiver transfer.

        // If burn amount was negative (mint amount is positive), 
        // mint new tokens. Otherwise, if burn amount is positive, 
        // perform regular burn. Mints and burns can't happen together.
        if( mintAmount > 0 ) {
            _mint( sender, mintAmount );
        }
        else if( burnAmount > 0 ) {
            _burn( sender, uint( burnAmount ) );
        }

        // Perform owner fee transfer.
        if( ownerFeeAmount > 0 )
            super._transfer( sender, OWNER_ADDRESS, ownerFeeAmount );

        // Finally, execute the final transfer from sender to receiver.
        super._transfer( sender, receiver, finalAmount );

        // Update transaction count.
        transactionCount++;

        // Compute new Pseudo-Random transfer hash, which must be
        // computed for every transfer, and is used in the
        // Finishing Stage as a pseudo-random unique value for 
        // every transfer, by which we determine whether lottery
        // should end on this transfer.
        //
        // Compute it like this: keccak the last (current) 
        // transferHashValue, msg.sender, now, and transaction count.

        transferHashValue = uint( keccak256( abi.encodePacked(
            transferHashValue, msg.sender, now, transactionCount ) ) );

        // Update burn rates, according to new state after this transfer.
        updateBurnRates();

        // Check if we should be starting a finishing stage now.
        checkFinishingStageConditions();

        // If we're on finishing stage, check for ending conditions.
        // If ending check is satisfied, the checkForEnding() function
        // starts ending operations.
        if( onFinishingStage )
            checkForEnding();

        // Un-lock mutex.
        transferOngoing = false;
    }


    /**
     *  Callback function, which is called from Randomness Provider,
     *  after it obtains a random seed to be passed to us, after
     *  we have initiated The Ending Stage, on which random seed
     *  is used to generate random factors for Winner Selection
     *  algorithm.
     *
     *  This function executes both Ending Stages (Part One and Two),
     *  and completes this lottery.
     */ 
    function finish_randomnessProviderCallback(
            uint256 randomSeed,
            uint256 /*callID*/ )
                                                external
                                                randomnessProviderOnly
    {
        require( !lotteryCompleted, "Lottery is already completed!" );

        ending_Stage_1 ();
        ending_Stage_2 ( randomSeed );
    }

    /**
     *  Alternative approach to Lottery Ending - is used only when
     *  Randomness Provider doesn't work, and doesn't call the
     *  above callback.
     *
     *  This alternative approach can be initiated by any external
     *  actor, by calling this function when specified conditions
     *  are met:
     *  - Lottery is inactive (isActive == false),
     *  - Lottery is Not Completed Yet (lotteryCompleted == false),
     *  - We're on the Ending Stage (onEndingStage == true),
     *  - Request to Randomness Provider was made at least 6 hours ago,
     *    and the randomness provider callback hasn't been called yet.
     *
     *  If these conditions are met, we can initiate the Alternative
     *  Ending, which performs basically the same operations
     */
    function finish_AlternativeEndingApproach()
                                                        external
    {
        require( !isActive, "Lottery must be inactive." );
        require( !lotteryCompleted, "Lottery must not be completed yet." );
        require( onEndingStage, "Lottery must be on the Ending Stage." );

        require( (now - finish_timeRandomSeedRequested) >
                 cfg.REQUIRED_TIME_WAITING_FOR_RANDOM_SEED,
                 "Required minimum waiting time hasn't passed yet!" );

        // At this point, we're sure that all conditions are met.
        // Start the Ending Stage functions, with the random seed
        // generated locally, using alternative approach!

        // Generate random seed based on sequence of holders in the
        // holders array, now, and last transferHashValue.

        uint randomSeed = uint( keccak256( abi.encodePacked(
            now, transferHashValue, holders ) ) );

        // Call the ending stages, with just-generated random seed.
        ending_Stage_1 ();
        ending_Stage_2 ( randomSeed );
    }


    /**
     *  Return this lottery's config, using ABIEncoderV2.
     */
    function getLotteryConfig()
                                                    external view
    returns( LotteryConfig memory ourConfig )
    {
        return cfg;
    }
}


/**
 *  The Lottery Storage contract.
 *
 *  This contract is used to store all Holder Data of a specific lottery
 *  contract - that includes lottery token holders list, and every
 *  holder's intermediate scores (HolderData structure).
 *
 *  When the lottery, that this storage belongs to, ends, then 
 *  this Storage contract also performs the whole winner selection
 *  algorithm, and distributes the prizes to winners.
 *  Before this procedure, Lottery contract must transfer the
 *  winner-belonging prize funds to this Storage contract.
 *
 *  Also, one of this contract's purposes is to split code,
 *  to avoid the 24kb code size limit error.
 *
 *  Notice, that Lottery and LotteryStorage contracts must have a
 *  1:1 relationship - every Lottery has only one Storage, and
 *  every Storage belongs to only one Lottery.
 *
 *  The LotteryStorage contracts are being created from the 
 *  LotteryStorageFactory contract, and only after that, the parent
 *  Lottery is created, so Lottery must initialize it's Storage,
 *  by calling initialize() function on freshly-created Storage,
 *  which set's the Lottery address, and locks it.
 */
contract LotteryStorage is CoreUniLotterySettings
{
    // ==================== State Variables ==================== //

    // The Lottery address that this storage belongs to.
    // Is set by the "initialize()", called by corresponding Lottery.
    Lottery lottery;

    // Struct of holder data & scores.
    struct HolderData 
    {
        // Bool used in final score computation, when iterating through
        // holders, to check for duplicates.  //bool isChecked;

        // The intermediate score factor variables.
        // Ether contributed: ( buys - sells ). Can be negative.
        int etherContributed;

        // Time x ether factor: (relativeTxTime * etherAmount).
        int timeFactors;

        // Token balance score factor of this holder - we use int,
        // for easier computation of player scores in our algorithms.
        int tokenBalance;

        // If this holder has generated his own referral ID, this is
        // that ID. If he hasn't generated an ID, this is zero.
        uint256 referralID;

        // If this holder provided a valid referral ID, this is the 
        // address of a referrer - the user who generated the said
        // referral ID.
        address referrer;

        // Number of all child referrees, including multi-level ones.
        // Updated by traversing child->parent way, incrementing
        // every node's counter by one.
        // Used in Winner Selection Algorithm, to determine how much
        // to divide the accumulated referree scores by.
        uint32 referreeCount;

        // Bonus score points, which can be given in certain events,
        // such as when player registers a valid referral ID.
        int32 bonusScore;

        // Accumulated referree score factors - ether contributed by
        // all referrees, time factors, and token balances of all
        // referrees.
        // Can be negative!
        int referree_etherContributed;
        int referree_timeFactors;
        int referree_tokenBalance;

        // Final Scores, as computed in ending_Stage_2().
        // TODO: Remove these in production release (Huge gas cost!) !!!
        uint32 finalTotalScore;
        uint32 finalRandomizedScore;
    }

    // ROOT_REFERRER constant.
    // Used to prevent cyclic dependencies on referral tree.
    address constant ROOT_REFERRER = address( 1 );

    // Minimum & maximum values for each score factor.
    // Updated for holders when they transfer tokens.
    // Used in winner selection algorithm, to normalize the scores in
    // a single loop, to avoid looping additional time to find min/max.
    int holderScore_etherContributed_min;
    int holderScore_etherContributed_max;

    int holderScore_timeFactors_min;
    int holderScore_timeFactors_max;

    int holderScore_tokenBalance_min;
    int holderScore_tokenBalance_max;

    // Array of holders.
    address[] public holders;

    // Holder array indexes mapping, for O(1) array element access.
    mapping( address => uint ) holderIndexes;

    // Mapping of holder data.
    mapping( address => HolderData ) public holderData;

    // Mapping of referral IDs to addresses of holders who generated
    // those IDs.
    mapping( uint256 => address ) referrers;

    // Final Score (end lottery score * randomValue) structure.
    struct FinalScore {
        address payable addr;
        uint score;
    }

    
    // A structure which is used by Winner Selection algorithm,
    // which is a subset of the LotteryConfig structure, containing
    // only items necessary for executing the Winner Selection algorigm.
    // More detailed member description can be found in LotteryConfig
    // structure description.
    struct WinnerAlgorithmConfig
    {
        // Individual player max score parts.
        int32 maxPlayerScore_etherContributed;
        int32 maxPlayerScore_tokenHoldingAmount;
        int32 maxPlayerScore_timeFactor;
        int32 maxPlayerScore_refferalBonus;

        // Holder count divisor, used to get the factor by which the
        // scores are multiplied, to take into account the holder amount.
        int16 playerScore_holderCountDivisor;

        // The Winner Prize Fund shares, as percentages of total
        // lottery profit shares.
        uint32[] winnerProfitShares;
    }


    // ==============       Internal (Private) Functions    ============== //

    // Lottery-Only modifier.
    modifier lotteryOnly
    {
        require( msg.sender == address( lottery ),
                 "Function can only be called by Lottery that this"
                 "Storage Contract belongs to!" );
        _;
    }


    // ============== [ BEGIN ] LOTTERY QUICKSORT FUNCTIONS ============== //

    /**
     *  QuickSort and QuickSelect algorithm functionality code.
     *
     *  These algorithms are used to find the lottery winners in
     *  an array of final random-factored scores.
     *  As the highest-scorers win, we need to sort an array to
     *  identify them.
     *
     *  For this task, we use QuickSelect to partition array into
     *  winner part (elements with score larger than X, where X is
     *  n-th largest element, where n is number of winners),
     *  and others (non-winners), who are ignored to save computation
     *  power.
     *  Then we sort the winner part only, using QuickSort, and
     *  distribute prizes to winners accordingly.
     */

    // Swap function used in QuickSort algorithms.
    //
    function QSort_swap( Lottery.FinalScore[] memory list, 
                         uint a, uint b )               
                                                        internal pure
    {
        Lottery.FinalScore memory tmp = list[ a ];
        list[ a ] = list[ b ];
        list[ b ] = tmp;
    }

    // Standard Hoare's partition scheme function, used for both
    // QuickSort and QuickSelect.
    //
    function QSort_partition( 
            Lottery.FinalScore[] memory list, 
            int lo, int hi )
                                                        internal pure
    returns( int newPivotIndex )
    {
        uint pivot = list[ uint( hi + lo ) / 2 ].score;
        int i = lo - 1;
        int j = hi + 1;

        while( true ) 
        {
            do {
                i++;
            } while( list[ uint( i ) ].score > pivot ) ;

            do {
                j--;
            } while( list[ uint( j ) ].score < pivot ) ;

            if( i >= j )
                return j;

            QSort_swap( list, uint( i ), uint( j ) );
        }
    }

    // QuickSelect's Lomuto partition scheme.
    //
    function QSort_LomutoPartition(
            Lottery.FinalScore[] memory list,
            uint left, uint right, uint pivotIndex )
                                                        internal pure
    returns( uint newPivotIndex )
    {
        uint pivotValue = list[ pivotIndex ].score;
        QSort_swap( list, pivotIndex, right );  // Move pivot to end
        uint storeIndex = left;
        
        for( uint i = left; i < right; i++ )
        {
            if( list[ i ].score > pivotValue ) {
                QSort_swap( list, storeIndex, i );
                storeIndex++;
            }
        }

        // Move pivot to its final place, and return the pivot's index.
        QSort_swap( list, right, storeIndex );
        return storeIndex;
    }

    // QuickSelect algorithm (iterative).
    //
    function QSort_QuickSelect(
            Lottery.FinalScore[] memory list,
            int left, int right, int k )
                                                        internal pure
    returns( int indexOfK )
    {
        while( true ) {
            if( left == right )
                return left;

            int pivotIndex = int( QSort_LomutoPartition( list, 
                    uint(left), uint(right), uint(right) ) );

            if( k == pivotIndex )
                return k;
            else if( k < pivotIndex )
                right = pivotIndex - 1;
            else
                left = pivotIndex + 1;
        }
    }

    // Standard QuickSort function.
    //
    function QSort_QuickSort(
            Lottery.FinalScore[] memory list,
            int lo, int hi )
                                                        internal pure
    {
        if( lo < hi ) {
            int p = QSort_partition( list, lo, hi );
            QSort_QuickSort( list, lo, p );
            QSort_QuickSort( list, p + 1, hi );
        }
    }

    // ============== [ END ]   LOTTERY QUICKSORT FUNCTIONS ============== //

    // ------------ Ending Stage - Winner Selection Algorithm ------------ //

    /**
     *  Compute the individual player score factors for a holder.
     *  Function split from the below one (ending_Stage_2), to avoid
     *  "Stack too Deep" errors.
     */
    function computeHolderIndividualScores( 
            address holder,
            WinnerAlgorithmConfig memory cfg )
                                                                internal
                                                                view
    returns( int individualScore )
    {
        // Use a PRECISION of 100.
        int PRECISION = 100;

        // Normalize the scores, by subtracting minimum and dividing
        // by maximum, to get the score values specified in cfg.
        // Use precision of 100, then round.
        //
        // Notice that we're using int arithmetics, so division 
        // truncates. That's why we use PRECISION, to simulate
        // rounding.
        //
        // This formula is better explained in example.
        // In this example, we use variable abbreviations defined
        // below, on formula's right side comments.
        //
        // Say, values are these in our example:
        // e = 4, eMin = 1, eMax = 8, MS = 5, P = 10.
        //
        // So, let's calculate the score using the formula:
        // ( ( ( (4 - 1) * 10 * 5 ) / (8 - 1) ) + (10 / 2) ) / 10 =
        // ( ( (    3    * 10 * 5 ) /    7    ) +     5    ) / 10 =
        // ( (         150          /    7    ) +     5    ) / 10 =
        // ( (         150          /    7    ) +     5    ) / 10 =
        // (                    20              +     5    ) / 10 =
        //                          25                       / 10 =
        //                        [ 2.5 ]                         = 2
        //
        // So, with truncation, we see that for e = 4, the score
        // is 2 out of 5 maximum.
        // That's because the minimum ether contributed was 1, and
        // maximum was 8.
        // So, 4 stays below the middle, and gets a nicely rounded 
        // score of 2.

        // Compute etherContributed.
        int score_etherContributed = ( (
            ( ( holderData[ holder ].etherContributed -       // e
                holderScore_etherContributed_min )                // eMin
              * PRECISION * cfg.maxPlayerScore_etherContributed ) // P * MS
            / ( holderScore_etherContributed_max -                // eMax
                holderScore_etherContributed_min )                // eMin
        ) + (PRECISION / 2) ) / PRECISION;

        // Compute timeFactors.
        int score_timeFactors = ( (
            ( ( holderData[ holder ].timeFactors -       // e
                holderScore_timeFactors_min )                // eMin
              * PRECISION * cfg.maxPlayerScore_timeFactor )  // P * MS
            / ( holderScore_timeFactors_max -                // eMax
                holderScore_timeFactors_min )                // eMin
        ) + (PRECISION / 2) ) / PRECISION;

        // Compute tokenBalance.
        int score_tokenBalance = ( (
            ( ( holderData[ holder ].tokenBalance -       // e
                holderScore_tokenBalance_min )                // eMin
              * PRECISION * cfg.maxPlayerScore_tokenHoldingAmount )
            / ( holderScore_tokenBalance_max -                // eMax
                holderScore_tokenBalance_min )                // eMin
        ) + (PRECISION / 2) ) / PRECISION;

        // Return the accumulated individual score (excluding referrees).
        return score_etherContributed + score_timeFactors +
               score_tokenBalance;
    }


    /**
     *  Compute the unified Referree-Score of a player, who's got
     *  the accumulated factor-scores of all his referrees in his 
     *  holderData structure.
     *
     *  @param individualToReferralRatio - an int value, computed 
     *      before starting the winner score computation loop, in 
     *      the ending_Stage_2 initial part, to save computation
     *      time later.
     *      This is the ratio of the maximum available referral score,
     *      to the maximum available individual score, as defined in
     *      the config (for example, if max.ref.score is 20, and 
     *      max.ind.score is 40, then the ratio is 20/40 = 0.5).
     *      
     *      We use this ratio to transform the computed accumulated
     *      referree individual scores to the standard referrer's
     *      score, by multiplying by that ratio.
     */
    function computeReferreeScoresForHolder( 
            address holder, 
            int individualToReferralRatio,
            WinnerAlgorithmConfig memory cfg )
                                                                internal
                                                                view
    returns( int unifiedReferreeScore )
    {
        // Use a precision of 100.
        int PRECISION = 100;

        // Now, compute the Referree's Accumulated Scores.
        //
        // Here we use the same formula as when computing individual
        // scores (in the function above), but we multiply the
        // Min & Max known score value by the referree count, because
        // the "referree_..." scores are accumulated scores of all
        // referrees that that holder has.
        // This way, we reach the uniform averaged score of all referrees,
        // just like we do with individual scores.
        //
        // Also, we don't divide them by PRECISION, to accumulate and use
        // the max-score-options in the main score computing function.

        int refCount = int( holderData[ holder ].referreeCount );

        // Compute etherContributed.
        int referreeScore_etherContributed = (
            ( ( holderData[ holder ].referree_etherContributed -
                holderScore_etherContributed_min * refCount )
              * PRECISION * cfg.maxPlayerScore_etherContributed )
            / ( holderScore_etherContributed_max * refCount -
                holderScore_etherContributed_min * refCount )
        );

        // Compute timeFactors.
        int referreeScore_timeFactors = (
            ( ( holderData[ holder ].referree_timeFactors -
                holderScore_timeFactors_min * refCount )
              * PRECISION * cfg.maxPlayerScore_timeFactor )
            / ( holderScore_timeFactors_max * refCount -
                holderScore_timeFactors_min * refCount )
        );

        // Compute tokenBalance.
        int referreeScore_tokenBalance = (
            ( ( holderData[ holder ].referree_tokenBalance -
                holderScore_tokenBalance_min * refCount )
              * PRECISION * cfg.maxPlayerScore_tokenHoldingAmount )
            / ( holderScore_tokenBalance_max * refCount -
                holderScore_tokenBalance_min * refCount )
        );

        // Accumulate 'em all !
        // Then, multiply it by the ratio of all individual max scores
        // (maxPlayerScore_etherContributed, timeFactor, tokenBalance),
        // to the maxPlayerScore_refferalBonus.
        // Use the same precision.
        int finalReferreeScore = ( (
                ( ( referreeScore_etherContributed +
                    referreeScore_timeFactors +
                    referreeScore_tokenBalance ) + (PRECISION / 2)
                ) / PRECISION
            ) * individualToReferralRatio
        ) / PRECISION;

        return finalReferreeScore;
    }


    // =================== PUBLIC FUNCTIONS =================== //


    /**
     *  Update current holder's score with given change values, and
     *  Propagate the holder's current transfer's score changes
     *  through the referral chain, updating every parent referrer's
     *  accumulated referree scores, until the ROOT_REFERRER or zero
     *  address referrer is encountered.
     */
    function updateAndPropagateScoreChanges(
            address holder,
            int etherContributed_change,
            int timeFactors_change,
            int tokenBalance_change )
                                                        public
                                                        lotteryOnly
    {
        // Update current holder's score.
        holderData[ holder ].etherContributed += etherContributed_change;
        holderData[ holder ].timeFactors += timeFactors_change;
        holderData[ holder ].tokenBalance += tokenBalance_change;

        // Check if scores are exceeding current min/max scores, 
        // and if so, update the min/max scores.

        // etherContributed:
        if( holderData[ holder ].etherContributed > 
            holderScore_etherContributed_max )
            holderScore_etherContributed_max = 
                holderData[ holder ].etherContributed;

        if( holderData[ holder ].etherContributed <
            holderScore_etherContributed_min )
            holderScore_etherContributed_min = 
                holderData[ holder ].etherContributed;

        // timeFactors:
        if( holderData[ holder ].timeFactors > 
            holderScore_timeFactors_max )
            holderScore_timeFactors_max = 
                holderData[ holder ].timeFactors;

        if( holderData[ holder ].timeFactors <
            holderScore_timeFactors_min )
            holderScore_timeFactors_min = 
                holderData[ holder ].timeFactors;

        // tokenBalance:
        if( holderData[ holder ].tokenBalance > 
            holderScore_tokenBalance_max )
            holderScore_tokenBalance_max = 
                holderData[ holder ].tokenBalance;

        if( holderData[ holder ].tokenBalance <
            holderScore_tokenBalance_min )
            holderScore_tokenBalance_min = 
                holderData[ holder ].tokenBalance;


        // Propagate the score through the referral chain.
        // Dive at maximum to the depth of 10, to avoid "Outta Gas"
        // errors.
        uint MAX_REFERRAL_DEPTH = 10;

        uint depth = 0;
        address referrerAddr = holderData[ holder ].referrer;

        while( referrerAddr != ROOT_REFERRER && 
               referrerAddr != address( 0 )  &&
               depth < MAX_REFERRAL_DEPTH )
        {
            // Update this referrer's accumulated referree scores.
            holderData[ referrerAddr ].referree_etherContributed +=
                etherContributed_change;

            holderData[ referrerAddr ].referree_timeFactors +=
                timeFactors_change;

            holderData[ referrerAddr ].referree_tokenBalance +=
                tokenBalance_change;

            // Move to the higher-level referrer.
            referrerAddr = holderData[ referrerAddr ].referrer;
            depth++;
        }
    }


    /** PAYABLE [ IN  ] <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     *  PAYABLE [ OUT ] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     *
     *  Function executes the Lottery Winner Selection Algorithm,
     *  and distributes the Winner Prize Fund to the selected winners.
     *
     *  This function is called from the Lottery's Ending Stage Part 2,
     *  which in turn gets called from the callback that the 
     *  Randomness Provider calls in Lottery contract
     *  (finish_randomnessProviderCallback), when Randomness Provider
     *  obtains a random seed and passes it to us.
     *
     *  However, this function is called only after Ending Stage Part 1
     *  completes (function ending_Stage_1()). 
     *  That function transfer Owner and Pool profit shares, and
     *  when Ending Stage Part 2 starts, all funds that are left,
     *  are distributed to lottery winners, through this function.
     *
     *  This is the final function that lottery performs actively - 
     *  and arguably the most important - because it determines 
     *  lottery winners through Winner Selection Algorithm, and 
     *  distributes the winning prizes to lottery winners.
     *
     *  After everything's distributed, Lottery notifies the Pool about
     *  our lottery finish, using Pool's finishLottery() function.
     *
     *  * This function receives Ether from the Lottery contract -
     *      Lottery transfers winner prize funds to the Storage contract,
     *      so that those funds could be distributed to winners,
     *      after executing the Winner Selection Algorithm.
     *
     *  * This function transfers Ether out of our contract:
     *    - Distributes the winner prize share to lottery winners.
     *
     *  @param randomSeed - the random seed, that Lottery obtained
     *      from the Randomness Provider, to be used in Winner 
     *      Selection algorithm.
     *
     *  @param cfg  - a subset of the Lottery Config, which includes
     *      winner score definitions, and other values, necessary for
     *      algorithm's execution.
     */
    function executeWinnerSelectionAlgorithm( 
            uint256 randomSeed,
            WinnerAlgorithmConfig memory cfg )
                                                        public
                                                        payable
                                                        lotteryOnly
    {
        // Now, we know that what's left in our contract's balance,
        // all of that belongs to the winner prizes, because the
        // Owner and Pool profit shares and initial funds were 
        // already transfered to their owners on Ending Stage Part 1.

        // Now, we gotta find the winners using a Randomized Score-Based
        // Winner Selection Algorithm.
        //
        // During transfers, all player intermediate scores 
        // (etherContributed, timeFactors, and tokenBalances) were
        // already set in every holder's HolderData structure,
        // during operations of updateHolderData_preTransfer() function.
        //
        // Minimum and maximum values are also known, so normalization
        // will be easy.
        // All referral tree score data were also properly propagated
        // during operations of updateAndPropagateScoreChanges() function.
        //
        // All we now have to do, is loop through holder array, and
        // compute randomized final scores for every holder, into
        // the Final Score array.

        // Declare the Final Score array.
        FinalScore[] memory finalScores = new FinalScore[] ( holders.length );

        // Precision of division operations.
        int PRECISION = 100;

        // Modulo used on random 256-bit number computed with keccak.
        uint RANDOM_MODULO = 1234567890;

        // Compute the precision-adjusted constant ratio of 
        // referralBonus max score to the player individual max scores.

        int individualToReferralRatio = 
            ( PRECISION * cfg.maxPlayerScore_refferalBonus ) /
            ( cfg.maxPlayerScore_etherContributed + 
              cfg.maxPlayerScore_timeFactor +
              cfg.maxPlayerScore_tokenHoldingAmount );

        // Max available player score.
        int maxAvailablePlayerScore = int(
                cfg.maxPlayerScore_etherContributed + 
                cfg.maxPlayerScore_timeFactor +
                cfg.maxPlayerScore_tokenHoldingAmount +
                cfg.maxPlayerScore_refferalBonus );

        // Holder Count factor. Used to adjust the scores to the
        // number of lottery token holder. Precision-adjusted.
        int holderCountFactor =
            ( int( holders.length ) * PRECISION ) /
            cfg.playerScore_holderCountDivisor;

        // Sync & update the OWNER_ADDRESS token balance score - because 
        // owner's address gets part of transfer fees, which aren't
        // updated into it's tokenBalance score on _transfer() runs.

        holderData[ OWNER_ADDRESS ].tokenBalance =
            int( lottery.balanceOf( OWNER_ADDRESS ) );

        // Check if it's mo'dan max or less'dan min.
        if( holderData[ OWNER_ADDRESS ].tokenBalance >
            holderScore_tokenBalance_max )
            holderScore_tokenBalance_max =
                holderData[ OWNER_ADDRESS ].tokenBalance;

        if( holderData[ OWNER_ADDRESS ].tokenBalance <
            holderScore_tokenBalance_min )
            holderScore_tokenBalance_min =
                holderData[ OWNER_ADDRESS ].tokenBalance;


        // Loop through all the holders.
        for( uint i = 0; i < holders.length; i++ )
        {
            // Skip if already checked this one 
            // (Now not needed, because we ensure that holders array
            //  doesn't contain duplicates).
            //if( holderData[ holders[ i ] ].isChecked )
            //    continue;

            // Now, add bonus score, and compute total player's score:
            // Bonus part, individual score part, and referree score part.
            int totalPlayerScore = 
                    holderData[ holders[ i ] ].bonusScore +
                    computeHolderIndividualScores( holders[ i ], cfg ) + 
                    computeReferreeScoresForHolder( holders[ i ],
                            individualToReferralRatio, cfg );

            // Check if total player score <= 0. If so, make it equal
            // to 1, because otherwise randomization won't be possible.
            if( totalPlayerScore <= 0 )
                totalPlayerScore = 1;

            // Now, check if it's not more than max! If so, lowerify.
            // This could have happen'd because of bonus.
            if( totalPlayerScore > maxAvailablePlayerScore )
                totalPlayerScore = maxAvailablePlayerScore;

            // Finally, multiply the score by the Holder Count Factor,
            // which is adjusted by precision.
            totalPlayerScore =  ( totalPlayerScore * holderCountFactor ) /
                                PRECISION;

            // All scores are found!
            // Now, randomize them, and add to Final Scores Array!
            // We use keccak to generate a random number from random seed,
            // using holder's address and i as nonces.

            uint modulizedRandomNumber = 
                uint( keccak256( abi.encodePacked( randomSeed, 
                                                   holders[ i ], i ) )
                    ) % RANDOM_MODULO;

            // Finally, push this holder's randomized score to array!
            finalScores[ i ].addr = address( uint160( holders[ i ] ) );
            finalScores[ i ].score = (
                uint( totalPlayerScore ) * modulizedRandomNumber
            );

            // Set holders[ i ] final score too.
            // This is used in unit testing.
            holderData[ holders[ i ] ].finalRandomizedScore =
                finalScores[ i ].score;

            holderData[ holders[ i ] ].finalTotalScore = 
                uint( totalPlayerScore );

            // Mark this holder as "checked", to not compute scores
            // again for him, in the event that there are duplicates.
            // NOW IT'S NOT NEEDED.
            //holderData[ holders[ i ] ].isChecked = true;
        }

        // All final scores are now computed.
        // Sort the array, to find out the highest scores!

        // Firstly, partition an array to only work on top K scores,
        // where K is the number of winners.
        // There can be a rare case where specified number of winners is
        // more than lottery token holders. We got that covered.

        require( finalScores.length > 0 );

        uint K = cfg.winnerProfitShares.length - 1;
        if( K > finalScores.length-1 )
            K = finalScores.length-1;   // Must be THE LAST ELEMENT's INDEX.

        // Use QuickSelect to do this.
        lotteryLibrary.QSort_QuickSelect( finalScores, 
                0, int( finalScores.length - 1 ), int( K ) );

        // Now, QuickSort only the first K items, because the rest
        // item scores are not high enough to become winners.
        lotteryLibrary.QSort_QuickSort( finalScores, 0, int( K ) );

        // Now, the winner array is sorted, with the highest scores
        // sitting at the first positions!

        // Now, we can loop through the first K elements, to send
        // prizes to lottery winners!
        for( uint i = 0; i <= K; i++ )
        {
            // Compute the fund share that this winner should get.
            uint prizeAmount = 
                ( ending_profitAmount * cfg.winnerProfitShares[ i ] ) /
                ( 100 * PERCENT );

            // Check the rare case that the prizeAmount is higher than
            // our ether balance, in case of rounding errors.
            bool breakNeeded = false;

            if( prizeAmount > address(this).balance ) 
            {
                prizeAmount = address(this).balance;
                breakNeeded = true;
            }

            // Transfer the prize!
            finalScores[ i ].addr.transfer( prizeAmount );

            // If breakNeeded, break.
            if( breakNeeded )
                break;
        }

        // All prizes are distributed! 
        // Now, the parent lottery will complete, and notify the Pool
        // about it's completion.
    }


    /**
     *  Add a holder to holders array.
     *  @param holder   - address of a holder to add.
     */
    function addHolder( address holder )
                                                        public
                                                        lotteryOnly
    {
        // Add it to list, and set index in the mapping.
        holders.push( holder );
        holderIndexes[ holder ] = holders.length - 1;
    }

    /**
     *  Removes the holder 'sender' from the Holders Array.
     *  However, this holder's HolderData structure persists!
     *
     *  Notice that no index validity checks are performed, so, if
     *  'sender' is not present in "holderIndexes" mapping, this
     *  function will remove the 0th holder instead!
     *  This is not a problem for us, because Lottery calls this
     *  function only when it's absolutely certain that 'sender' is
     *  present in the holders array.
     *
     *  @param sender   - address of a holder to remove.
     *      Named 'sender', because when token sender sends away all
     *      his tokens, he must then be removed from holders array.
     */
    function removeHolder( address sender )
                                                        public
                                                        lotteryOnly
    {
        // Get index of the sender address in the holders array.
        uint index = holderIndexes[ sender ];

        // Remove the sender from array, by copying last element's
        // value into the index'th element, where sender was before.
        holders[ index ] = holders[ holders.length - 1 ];

        // Remove the last element of array, which we've just copied.
        holders.pop();

        // Update indexes: remove the sender's index from the mapping,
        // and change the previoulsy-last element's index to the
        // one where we copied it - where sender was before.
        delete holderIndexes[ sender ];
        holderIndexes[ holders[ index ] ] = index;
    }


    /**
     *  Set holder's bonus score.
     *  Note: Holder must be already present in the holders array!
     */
    function setHolderBonusScore( 
            address holder,
            int32 bonusScore )
                                                    public
                                                    lotteryOnly
    {
        holderData[ holder ].bonusScore = bonusScore;
    }

    /**
     *  Get holder array length.
     */
    function getHolderCount()
                                                    public view
    returns( uint )
    {
        return holders.length();
    }


    /**
     *  Generate a referral ID for a token holder.
     *  Referral ID is used to refer other wallets into playing our
     *  lottery.
     *  - Referrer gets bonus points for every wallet that bought 
     *    lottery tokens and specified his referral ID.
     *  - Referrees (wallets who got referred by registering a valid
     *    referral ID, corresponding to some referrer), get some
     *    bonus points for specifying (registering) a referral ID.
     *
     *  Referral ID is a uint256 number, which is generated by
     *  keccak256'ing the holder's address, holder's current
     *  token ballance, and current time.
     */
    function generateReferralID( address holder )
                                                            public
                                                            lotteryOnly
    returns( uint256 referralID )
    {
        // Check if holder has some tokens, and doesn't
        // have his own referral ID yet.
        require( holderData[ holder ].tokenBalance != 0,
                 "holder doesn't have any lottery tokens!" );

        require( holderData[ holder ].referralID == 0,
                 "Holder already has a referral ID!" );

        // Generate a referral ID with keccak.
        uint256 refID = uint256( keccak256( abi.encodePacked( 
                holder, holderData[ holder ].tokenBalance, now ) ) );

        // Specify the ID as current ID of this holder.
        holderData[ holder ].referralID = refID;

        // If this holder wasn't referred by anyone (his referrer is
        // not set), and he's now generated his own ID, he won't
        // be able to register as a referree of someone else 
        // from now on.
        // This is done to prevent circular dependency in referrals.
        // Do it by setting a referrer to ROOT_REFERRER address,
        // which is an invalid address (address(1)).
        if( holderData[ holder ].referrer == address( 0 ) )
            holderData[ holder ].referrer = ROOT_REFERRER;

        // Create a new referrer with this ID.
        referrers[ refID ] = holder;
        
        return refID;
    }


    /**
     *  Register a referral for a token holder, using a valid
     *  referral ID got from a referrer.
     *  This function is called by a referree, who obtained a
     *  valid referral ID from some referrer, who previously
     *  generated it using generateReferralID().
     *
     *  You can only register a referral once!
     *  When you do so, you get bonus referral points!
     */
    function registerReferral(
            address holder,
            uint32 referralRegisteringBonus,
            uint256 referralID )
                                                            public
                                                            lotteryOnly
    returns( address _referrerAddress )
    {
        // Check if this holder has some tokens, and if he hasn't
        // registered a referral yet.
        require( holderData[ holder ].tokenBalance != 0,
                 "holder doesn't have any lottery tokens!" );

        require( holderData[ holder ].referrer == address( 0 ),
                 "holder already has registered a referral!" );

        // Get the referrer's address from his ID, and specify
        // it as a referrer of holder.
        holderData[ holder ].referrer = referrers[ referralID ];

        // Bonus points are added to this holder's score for
        // registering a referral!
        holderData[ holder ].bonusScore = referralRegisteringBonus;

        // Increment number of referrees for every parent referrer,
        // by traversing a referral tree child->parent way.
        address referrerAddr = holderData[ holder ].referrer;

        // Set the return value.
        _referrerAddress = referrerAddr;

        // Traverse a tree.
        while( referrerAddr != ROOT_REFERRER && 
               referrerAddr != address( 0 ) )
        {
            // Increment referree count for this referrrer.
            holderData[ referrerAddr ].referreeCount++;

            // Update the Referrer Scores of the referrer, adding this
            // referree's scores to it's current values.
            holderData[ referrerAddr ].referree_etherContributed +=
                holderData[ holder ].etherContributed;

            holderData[ referrerAddr ].referree_timeFactors +=
                holderData[ holder ].timeFactors;

            holderData[ referrerAddr ].referree_tokenBalance +=
                holderData[ holder ].tokenBalance;

            // Move to the higher-level referrer.
            referrerAddr = holderData[ referrerAddr ].referrer;
        }

        return _referrerAddress;
    }


    /**
     *  Initialization function.
     *  Here, we bind our contract to the Lottery contract that 
     *  this Storage belongs to.
     *  The parent lottery must call this function - hence, we set
     *  "lottery" to msg.sender.
     *
     *  When this function is called, our contract must be not yet
     *  initialized - "lottery" address must be Zero!
     */
    function initialize()
    {
        require( address( lottery ) == address( 0 ),
                 "Storage is already initialized!" );

        // Set the Lottery address (msg.sender can't be zero),
        // and thus, set our contract to initialized!
        lottery = Lottery( msg.sender );
    }

}



/**
 *  Contract for generating a Default LotteryConfig.
 *  This contract is deployed by the Pool as a single instance, and
 *  is used by Pool and offchain applications.
 */
contract UniLotteryConfigGenerator is CoreUniLotterySettings
{
    function getDefaultConfig() 
                                                    external pure 
    returns ( Lottery.LotteryConfig memory cfg )
    {
        // Fill the default values for the LotteryConfig.
        // Detailed description of LotteryConfig is above, on struct
        // declaration in Lottery contract.

        cfg.lotteryType = Lottery.LotteryType.UniswapLottery;

        cfg.tokenName   = "UniLottery Token";
        cfg.tokenSymbol = "ULT";
        cfg.tokenDecimals = 18;

        // Initial funds (initial market cap) of a lottery.
        // By default, 10 ETH.
        cfg.initialFunds = 10 ether;

        // Lottery transaction fee.
        cfg.ownerLotteryFee = ( 1 * PERCENT ) / 2;  // 0.5 %

        // Pool and Owner profit shares.
        cfg.ownerProfitShare = 10 * PERCENT;    // 10 %
        cfg.poolProfitShare  = 30 * PERCENT;    // 30 %

        // Maximum lifetime of a lottery - 2 weeks.
        cfg.maxLifetime = 2 weeks;

        // If using standalone mode, selling tokens to contract is
        // allowed.
        cfg.standaloneMode_sellingToContractAllowed = true;

        // cfg.randomnessProvider;  // Set by pool.

        // Initial supply is 10 million tokens.
        cfg.initialTokenSupply = 10000000 * ( 10 ** cfg.tokenDecimals );

        cfg.fixedBurnMode = false;  // Use custom burn mode.

        // Don't mint new tokens if burn becomes negative.
        cfg.mintTokensOnNegativeBurn = false; 

        // cfg.burn_fixedRate; // = 0

        // Initial burn rate is the same for all types of tx: 5 %
        cfg.burn_sellerRate_initial = 5 * int32(PERCENT);
        cfg.burn_buyerRate_initial  = 5 * int32(PERCENT);
        cfg.burn_defaultRate_initial= 5 * int32(PERCENT);

        // Minimum burn rates for the three categories.
        cfg.burn_sellerRate_min  = 5 * int32(PERCENT);
        cfg.burn_buyerRate_min   = 1 * int32(PERCENT);
        cfg.burn_defaultRate_min = 5 * int32(PERCENT);

        // Maximum burn rates for the three categories.
        cfg.burn_sellerRate_max  = 30 * int32(PERCENT);
        cfg.burn_buyerRate_max   = 5 * int32(PERCENT);
        cfg.burn_defaultRate_max = 30 * int32(PERCENT);


        // We use transaction and holder burn increases.
        cfg.burnIncrease_perTransaction = true;
        cfg.burnIncrease_perHolder      = true;
        cfg.burnIncrease_perFundGains   = false;

        cfg.burn_sellerRateIncrease_transaction = 1 * int32(BASIS_POINT); // 0.01%
        cfg.burn_buyerRateIncrease_transaction  = 0; 
        cfg.burn_defaultRateIncrease_transaction = 1 * int32(BASIS_POINT); // 0.01%

        cfg.burn_sellerRateIncrease_holder = 3 * int32(BASIS_POINT);  // 0.03%
        cfg.burn_buyerRateIncrease_holder  = -3 * int32(BASIS_POINT); // Decrease!
        cfg.burn_defaultRateIncrease_holder= 3 * int32(BASIS_POINT);  // 0.03%

        // Fund gains burn increase is unused.
        // cfg.burn_sellerRateIncrease_FundGains;
        // cfg.burn_buyerRateIncrease_FundGains;
        // cfg.burn_defaultRateIncrease_FundGains;

        // Perform increases on each holder/transaction
        cfg.burnIncreaseSpecs_transcation_step  = 1;
        cfg.burnIncreaseSpecs_holder_step       = 1;
        // cfg.burnIncreaseSpecs_FundGains_step;

        // Max. 5% of initial supply is allowed to own by a single wallet.
        cfg.maxAmountForWallet_percentageOfSupply = 5 * PERCENT;

        // After lottery funds gain 300% in ETH value, deny all sells
        // which could drop the fund value lower.
        cfg.fundGainRequirement_denySells = 300 * PERCENT;

        // Start finishing stage, if fund value in ETH gains by 1000% ,
        // AND number of holders reaches 200.
        // Also, lottery must be active for at least 6 hours.
        cfg.finishCriteria_minFundEthGains = 1000 * PERCENT;
        cfg.finishCriteria_minNumberOfHolders = 200;
        cfg.finishCriteria_minTimeActive = 6 hours;

        // We don't reset the probability if finishing stage stops.
        cfg.finish_resetProbabilityOnStop = false;

        // Initial probability that transaction will end lottery
        // on finishing stage, is 1% .
        cfg.finish_initialProbability = 1 * PERCENT;

        // Probability of ending increases with each new transaction.
        cfg.finish_probabilityIncreaseStep_transaction = 1 * PERCENT;
        cfg.finish_probabilityIncreaseStep_holder = 0;

        // Winner selection algorithm scores. Max score is 40.
        cfg.maxPlayerScore_etherContributed     = 10;
        cfg.maxPlayerScore_tokenHoldingAmount   = 5;
        cfg.maxPlayerScore_timeFactor       = 5;
        cfg.maxPlayerScore_refferalBonus    = 20;

        // Time factor update interval (time divisor).
        // By default, 1 minute (60 secs).
        cfg.timeFactorDivisor = 60;

        // Increase player scores for every 70 holders.
        cfg.playerScore_holderCountDivisor = 70;

        // Bonus points for a referree, for registering a valid referral.
        // By default, 2 points. That's very much!
        cfg.playerScore_referralRegisteringBonus = 2;

        // The constant - required amount of time that must pass after
        // the request to Randomness Provider has been made, for
        // external actors to be able to initiate alternative ending.
        cfg.REQUIRED_TIME_WAITING_FOR_RANDOM_SEED = 6 hours;


        // Amount of market cap profits to be distributed to
        // lottery winners is 60% , split for winners as follows:
        cfg.winnerProfitShares = new uint32[] ( 20 );

        cfg.winnerProfitShares[ 0 ] = 15 * PERCENT;
        cfg.winnerProfitShares[ 1 ] = 10 * PERCENT;
        cfg.winnerProfitShares[ 2 ] = 8 * PERCENT;
        cfg.winnerProfitShares[ 3 ] = 6 * PERCENT;
        cfg.winnerProfitShares[ 4 ] = 5 * PERCENT;
        cfg.winnerProfitShares[ 5 ] = 4 * PERCENT;
        cfg.winnerProfitShares[ 6 ] = 3 * PERCENT;
        cfg.winnerProfitShares[ 7 ] = 2 * PERCENT;
        cfg.winnerProfitShares[ 8 ] = 1 * PERCENT;
        cfg.winnerProfitShares[ 9 ] = 1 * PERCENT;
        // 5 percent left - 0.5% to 10 holders.
        cfg.winnerProfitShares[ 10 ] = ( 1 * PERCENT ) / 2;
        cfg.winnerProfitShares[ 11 ] = ( 1 * PERCENT ) / 2;
        cfg.winnerProfitShares[ 12 ] = ( 1 * PERCENT ) / 2;
        cfg.winnerProfitShares[ 13 ] = ( 1 * PERCENT ) / 2;
        cfg.winnerProfitShares[ 14 ] = ( 1 * PERCENT ) / 2;
        cfg.winnerProfitShares[ 15 ] = ( 1 * PERCENT ) / 2;
        cfg.winnerProfitShares[ 16 ] = ( 1 * PERCENT ) / 2;
        cfg.winnerProfitShares[ 17 ] = ( 1 * PERCENT ) / 2;
        cfg.winnerProfitShares[ 18 ] = ( 1 * PERCENT ) / 2;
        cfg.winnerProfitShares[ 19 ] = ( 1 * PERCENT ) / 2;

        //return cfg;
    }
}



